# Асинхронность с генераторами ES6

*Перевод статьи Kyle Simpson: [Going Async With ES6 Generators](https://davidwalsh.name/async-generators)*

*Дата публикации: 03.08.2014*

## Генераторы ES6: Полная серия

1. [Основы генераторов ES6](bonus/es6_generators_basic/README.md)
2. [Глубокое погружение в генераторы ES6](bonus/es6_generators_dive/README.md)
3. [Асинхронность с генераторами ES6](bonus/async_generators/README.md)
4. [Параллелизм с генераторами ES6](bonus/concurrent_generators/README.md)

Теперь, когда вы знакомы с [основами генераторов ES6](bonus/es6_generators_basic/README.md) и [освоились с ними](bonus/es6_generators_dive/README.md), пришло время использовать для улучшения наше кода в реальной жизни.

Основная сила генераторов заключается в том, что они обеспечивают однопоточный синхронный стиль кода, **позволяя скрыть асинхронность как деталь реализации**. Это даёт нам возможность очень естественным образом выразить последовательность шагов/инструкций нашей программы без использования асинхронного синтаксиса и подводных камней.

Другими словами, мы достигаем прекрасного **разделения ответственности** с помощью отделения потребления значений (логика генератора) от реализации асинхронного получения этих значений (метод `next(...)` итератора).

А что получаем в результате? Всю мощь асинхронного кода со всей простотой чтения и поддержки синхронного кода.

Итак, как нам достичь этого успеха?

## Простейшая асинхронная функция

В самом простом генераторе не требуется ничего *дополнительного* для обработки асинхронных возможностей.

Например, давайте представим, что у вас уже есть этот код:

```js
function makeAjaxCall(url,cb) {
    // делаем какой-нибудь ajax-запрос
    // вызываем `cb(result)` после завершения
}

makeAjaxCall( "http://some.url.1", function(result1){
    var data = JSON.parse( result1 );

    makeAjaxCall( "http://some.url.2/?id=" + data.id, function(result2){
        var resp = JSON.parse( result2 );
        console.log( "Значение, которое вы запрашивали: " + resp.value );
    });
} );
```

Вот как можно сделать то же самое с использованием генератора (без дополнительного декорирования):

```js
function request(url) {
    // здесь мы прячем асинхронность,
    // убирая её из основного кода нашего генератора
    // вызов `it.next(..)` возобновляет генератор
    makeAjaxCall( url, function(response){
        it.next( response );
    } );
    // Внимание: здесь ничего не возвращается!
}

function *main() {
    var result1 = yield request( "http://some.url.1" );
    var data = JSON.parse( result1 );

    var result2 = yield request( "http://some.url.2?id=" + data.id );
    var resp = JSON.parse( result2 );
    console.log( "Значение, которое вы запрашивали: " + resp.value );
}

var it = main();
it.next(); // здесь всё начинается
```

Давайте разберёмся, как это работает.

Вспомогательная функция `request(...)` оборачивает `makeAjaxCall(...)`, чтобы убедиться, что в колбэке вызывается метод `next(...)` итератора.

Как вы можете заметить, вызов `request("...")` *не возвращает значения* (другими словами, он возвращает значение `undefined`). Здесь этот момент не существеннен, но на него стоит обратить внимание, так как мы вернёмся к этому позже: мы получаем здесь `yield undefined`.

Далее мы вызываем выражение `yield ...` (со значением `undefined`), которое не делает ничего, только приостанавливает наш генератор в этой точке. Генератор будет ждать, пока не возобновится с помощью метода `it.next(...)`, который мы поставили в очередь (как колбэк) после завершения нашего ajax-запроса. 

А что происходит с *результатом* выражения `yield ...`? Мы присваиваем его переменной `result1`. Как мы здесь получим результат ajax-запроса?

Поскольку метод `it.next()` вызывается в колбэке, колбэк передаёт в него ответ ajax-запроса. Это значит, что результат ajax-запроса будет передан обратно в генератор в ту точку, где он был приостановлен, а именно в выражение `result1 = yield ...`!

Это действительно круто и супер мощно. В сущности, `result1 = yield request(...)` **запрашивает значение**, но от нас (почти!) полностью скрыто — по крайне мере здесь об этом не нужно беспокоиться — что реализация под капотом делает это асинхронно. Асинхронность скрыта за возможностью `yield` приостанавливать выполнение и возобновлять его из другой функции, поэтому наш код делает **(как бы) синхронный запрос**.

В точности то же самое происходит со вторым выражением `result2 = yield result(...)`: оно прозрачно приостанавливает и возобновляет выполнение, отдаёт значение, которое мы запрашиваем, при этом в этой точке не нужно беспокоиться ни о каких деталях асинхронности.

Конечно, здесь присутствует `yield`, который тонко намекает, что в этот момент *может произойти* что-то волшебное (например, асинхронный вызов). Но `yield` — это довольно незначительный синтаксический сигнал/накладные расходы по сравнению с адскими кошмарами вложенных колбэков (или даже накладными расходами цепочки обещаний!).

Заметьте также, что я сказал, «может произойти». Это очень мощная вещь сама по себе. Код выше всегда делает асинхронный ajax-вызов, но **что, если это не так?** Что делать, если позже мы изменили нашу программу, добавили кэширование предыдущих ответов? Или какой-то параметр в URL-адресе нашего приложения может в некоторых случаях выполнить ajax-запрос сразу, без необходимости фактически получать ответ с сервера?

Мы можем изменить реализацию `request(...)` так:
s
```js
var cache = {};

function request(url) {
    if (cache[url]) {
        // "отложить" кэшированный ответ достаточно долго
        // чтобы завершить текущий поток выполнения
        setTimeout( function(){
            it.next( cache[url] );
        }, 0 );
    }
    else {
        makeAjaxCall( url, function(resp){
            cache[url] = resp;
            it.next( resp );
        } );
    }
}
```

**Примечание:** тонкая, сложная деталь здесь — необходимость отсрочки `setTimeout (... 0)` в случае, когда в кэше уже есть результат. Если мы просто вызовем `it.next(...)`, это приведёт к ошибке, поскольку (и это тонкая часть) технически в этот момент генератор ещё не приостановлен. Сначала будет полностью выполнена функция `request(...)`, а затем `yield` приостановит выполнение генератора. Поэтому мы не можем вызвать `request(...)`, пока генератор всё ещё запущен (`yield` не был обработан). Но мы можем вызвать `it.next(...)` «позже», непосредственно после того, как завершится текущий поток выполнения, с помощью «хака» с `setTimeout(...0)`. **У нас будет более приятное решение для этого ниже.**

Теперь наш код генератора выглядит так:

```js
var result1 = yield request( "http://some.url.1" );
var data = JSON.parse( result1 );
..
```

**Видите?!** Логика генератора (или наш *поток управления*) не изменилась **совсем** по сравнению с версией без кэширования выше.

Код в генераторе `*main()` по-прежнему запрашивает значение и останавливается, пока не получит результат. В нашем текущем сценарии, эта «пауза» может быть относительно долгой (делается фактический запрос на сервер, возможно, 300-800 мс) или почти мгновенной (отсрочка с использованием `setTimeout(...0)`). Но для нашего потока управления это не имеет значения.

В этом заключается настоящая мощь **абстрагирования асинхронности как детали реализации**.

## Улучшенная асинхронная функция

Описанный выше подход достаточно хорош для простых асинхронных генераторов. Но он быстро достигнет своего предела, поэтому нам понадобится более мощный механизм асинхронного взаимодействия с нашими генераторами, который способен выполнять намного больше тяжелой работы. Какой механизм? **Промисы**.

Если вы не до конца чётко понимаете промисы ES6, я написал о них расширенную [серию из 5 постов](http://blog.getify.com/promises-part-1/). Сходите почитайте. Я буду *ждать*, пока вы не вернётесь. Ха-ха. Тонкая, банальная шутка об асинхронности! 

Примеры кода с ajax-запросами, которые мы рассматривали ранее, страдают от проблем [инверсии управления](http://blog.getify.com/promises-part-2/) (или «callback hell»/«ад колбэков»). Вот некоторые наблюдения о том, чего нам до сих пор не хватает:

1. Нет чёткого способа обработки ошибок. Как мы [узнали из предыдущего поста](bonus/es6_generators_dive), мы *могли бы* обнаружить ошибку в ajax-вызове (каким-то образом) и передать её обратно в генератор с помощью `it.throw(...)`, а затем использовать `try...catch` в генераторе для обработки этой ошибки. Но в данном случае придётся проделать много ручной работы, и возможно, этот код нельзя будет переиспользовать, если мы создадим много генераторов в нашей программе.
2. Если утилита `makeAjaxCall(...)` не находится под нашим контролем, и иногда вызывает колбэк несколько раз или одновременно сигнализирует об успехе и об ошибке, то наш генератор будет работать с ошибками (непойманные ошибки, некорректные значения и т. д.). Обработка и предотвращение таких проблем — много повторяющейся ручной работы.
3. Часто нам приходится выполнять несколько *задач* «параллельно» (например, два одновременных ajax-запроса). Поскольку каждое выражение `yield` в генераторе представляет собой одну точку паузы, два или более запроса не могут запускаться одновременно — они должны запускаться по очереди, по порядку. Таким образом, не совсем ясно, как запустить несколько задач в одной точке `yield` генератора, не делая под капотом много дополнительной работы.

Как вы можете видеть, все эти проблемы *решаемы*, но кто действительно хочет каждый раз изобретать эти решения. Нам нужен более мощный шаблон, разработанный специально как [надежное, многоразовое решение](http://blog.getify.com/promises-part-3/) для асинхронного кода на основе генераторов.

Какой шаблон? **Отдавать промисы с помощью yield** и позволить им возобновить генератор, когда они успешно выполнятся.

Помните, что выше мы вызывали `yield request(...)`, а вспомогательная функция `request(...)` не имела возвращаемого значения, т.е. фактически это было выражение `yield undefined`?

Давайте это немного подкорректируем. Изменим нашу функцию `request(...)` так, чтобы она возвращала промис, таким образом мы будем **отдавать в генераторе промис** (а не `undefined`).

```js
function request(url) {
    // Внимание: сейчас возвращается промис!
    return new Promise( function(resolve,reject){
        makeAjaxCall( url, resolve );
    } );
}
```

Теперь функция `request(...)` создаёт промис, который будет выполнен, когда завершится ajax-запрос. Этот промис отдаётся генератором. Что дальше?

Нам нужна вспомогательная функция, которая управляет итератором генератора. Она будет получать отданные промисы и возобновлять генератор. Я назову эту вспомогательную функцию `runGenerator(...)`:

```js
// (асинхронный) запуск генератора при завершении
// Внимание: упрощённый подход - здесь нет обработки ошибок
function runGenerator(g) {
    var it = g(), ret;

    // асинхронная итерация по генератору
    (function iterate(val){
        ret = it.next( val );

        if (!ret.done) {
            // проверка "это промис?"
            if ("then" in ret.value) {
                // ждём завершения промиса
                ret.value.then( iterate );
            }
            // непосредственное значение: просто отправляем его обратно
            else {
                // избегаем синхронной рекурсии
                setTimeout( function(){
                    iterate( ret.value );
                }, 0 );
            }
        }
    })();
}
```

Ключевые моменты, на которые следует обратить внимание:

1. Мы автоматически инициализируем генератор (создаем его итератор `it`) и асинхронно запускаем его до завершения (`done: true`).
2. Мы проверяем, что генератор отдаёт промис (возвращаемое значение из каждого метода `it.next(...)`). Если так, мы регистрируем обработчик `then(...)` промиса и ждём его завершения.
3. Если генератор сразу отдаёт значение (а не промис), мы просто отправляем его обратно в генератор, чтобы он немедленно возобновился.

Как мы теперь будем это использовать?

```js
runGenerator( function *main(){
    var result1 = yield request( "http://some.url.1" );
    var data = JSON.parse( result1 );

    var result2 = yield request( "http://some.url.2?id=" + data.id );
    var resp = JSON.parse( result2 );
    console.log( "Значение, которое вы запрашивали: " + resp.value );
} );
```

Бам! Подождите... это же **тот самый код генератора, который мы использовали ранее?** Да. И снова, в этом проявляется мощность генераторов. Тот факт, что мы теперь создаём промис, отдаём его наружу и возобновляем генератор, когда промис выполнится — **ВСЁ ЭТО «СКРЫТЫЕ» ДЕТАЛИ РЕАЛИЗАЦИИ!** На самом деле не скрытые, просто отделены от кода, который использует значения (от потока управления в генераторе).

Мы отдаём промис из генератора, а потом посылаем обратно его значение, когда он завершится, поэтому `result1 = yield request(...)` как и раньше получает значение.

Но теперь мы используем промисы для управления асинхронной частью кода генератора, мы решаем все проблемы инверсии управления, которые были в подходе на основе колбэков. Используя генераторы + промисы, мы получаем решение всех перечисленных выше проблем «бесплатно»:

1. Теперь у нас есть встроенный механизм обработки ошибок, который просто подключить. Мы не показали этого в функции `runGenerator(...)` выше, но это не сложно — слушать все ошибки промиса и передавать их обратно с помощью `it.throw(...)`. Тогда мы можем использовать `try...catch` в генераторе, чтобы отловить и обработать эти ошибки.
2. Мы получаем весь [контроль/доверие](http://blog.getify.com/promises-part-2/#uninversion), которые предлагают промисы. Не беспокойства, не суеты.
3. У промисов есть много мощных абстракций, которые автоматически обрабатывают сложности нескольких «параллельных» задач и т. д. Например, `yield Promise.all([ ... ])` берёт массив промисов для «параллельных» задач и отдаёт его как один промис, который ждёт выполнения всех дочерних промисов (в произвольном порядке), прежде чем продолжить выполнение. Результатом выражения `yield` будет массив результатов всех дочерних промисов, в том порядке, в котором они были запрошены (независимо от порядка завершения).

Во-первых, рассмотрим обработку ошибок:

```js
// предположение: `makeAjaxCall(...)` ожидает колбэк в стиле "error-first"/"сначала ошибка" (опущен для краткости)
// предположение: `runGenerator(..)` теперь также обрабатывает ошибки (опущено для краткости)

function request(url) {
    return new Promise( function(resolve,reject){
        // передаём колбэк в стиле error-first
        makeAjaxCall( url, function(err,text){
            if (err) reject( err );
            else resolve( text );
        } );
    } );
}

runGenerator( function *main(){
    try {
        var result1 = yield request( "http://some.url.1" );
    }
    catch (err) {
        console.log( "Ошибка: " + err );
        return;
    }
    var data = JSON.parse( result1 );

    try {
        var result2 = yield request( "http://some.url.2?id=" + data.id );
    } catch (err) {
        console.log( "Ошибка: " + err );
        return;
    }
    var resp = JSON.parse( result2 );
    console.log( "Значение, которое вы запрашивали " + resp.value );
} );
```

Если промис завершится неуспешно (или произойдёт любая другая ошибка/исключение), неудача промиса превратится в ошибку генератора (здесь не показано — с помощью `it.throw(...)` в генераторе), которая будет обработана конструкцией `try...catch`.

Теперь давайте рассмотрим более сложный пример, который использует промисы для управления ещё более сложной асинхронной логикой:

```js
function request(url) {
    return new Promise( function(resolve,reject){
        makeAjaxCall( url, resolve );
    } )
    // делаем некоторую пост-обработку возвращаемого текста
    .then( function(text){
        // мы только что получили URL (перенаправление)?
        if (/^https?:\/\/.+/.test( text )) {
            // делаем другой подзапрос по новому URL
            return request( text );
        }
        // иначе предположим, что текст - это то, что мы ожидали
        else {
            return text;
        }
    } );
}

runGenerator( function *main(){
    var search_terms = yield Promise.all( [
        request( "http://some.url.1" ),
        request( "http://some.url.2" ),
        request( "http://some.url.3" )
    ] );

    var search_results = yield request(
        "http://some.url.4?search=" + search_terms.join( "+" )
    );
    var resp = JSON.parse( search_results );

    console.log( "Search results: " + resp.value );
} );
```

`Promise.all([...])` создаёт промис, который ждёт три дочерних промиса, и отдаёт этот главный промис в функцию `runGenerator(...)`. Вложенные промисы могут получить ответ в виде другого URL и добавить новый промис в цепочку. [Прочитайте этот раздел в статье](http://blog.getify.com/promises-part-5/#the-chains-that-bind-us), чтобы узнать больше о цепочках промисов.

Любая сложность асинхронности, с которой могут справиться промисы, вы можете выразить синхронно с помощью генераторов, отдающих промисы (или промисы промисов и т.д.). **Это лучшее из обоих миров.**

## runGenerator(..): вспомогательные библиотеки

Мы написали собственную утилиту `runGenerator(...)`, чтобы включить связку генератор + промис. Мы даже опустили (ради краткости) полную реализацию этой утилиты, так как есть нюансы, связанные с обработкой ошибок.

Но вы ведь не хотите писать свой собственную функцию `runGenerator(...)`, не так ли?

Я так и думал.

Есть несколько разнообразных библиотек, которые предоставляют именно такую функцию. Я не буду их освещать, но вы можете взглянуть на `Q.spawn(...)`, `co(...)` и т. д.

Однако я кратко расскажу об утилите из моей собственной библиотеки: [плагин `runner(...)` из asynquence](http://github.com/getify/asynquence), так как я думаю, что он предлагает некоторые уникальные возможности по сравнению с остальными. Я написал [углубленную серию статей из 2-х частей об asynquence](https://davidwalsh.name/asynquence-part-1/), если вам интересно узнать больше, чем краткое объяснение здесь. 

Во-первых, *asynquence* предоставляет утилиты для автоматической обработки колбэков из приведенных выше фрагментов в стиле «error-first»:

```js
function request(url) {
    return ASQ( function(done){
        // передаём здесь колбэк в стиле error-first
        makeAjaxCall( url, done.errfcb );
    } );
}
```

Так **намного лучше**, не так ли!?

Далее, плагин `runner(...)` использует генератор прямо в середине последовательности *asynquence* (асинхронной серии шагов), поэтому вы можете передавать сообщение(-я) с предыдущего шага, а ваш генератор может передавать сообщение(-я) на следующий шаг, и все ошибки автоматически распространяются так, как вы ожидали:

```js
// сначала вызываем функцию `getSomeValues()`, создающую последовательность/промис,
// затем подключаем к последовательности больше асинхронных шагов
getSomeValues()

// теперь используем генератор для обработки полученных значений
.runner( function*(token){
    // token.messages будет заполняться любыми сообщениями
    // с предыдущего шага
    var value1 = token.messages[0];
    var value2 = token.messages[1];
    var value3 = token.messages[2];

    // делаем три параллельных ajax-запроса, дожидаемся
    // их завершения (в любом порядке)
    // Примечание: `ASQ().all(..)` - это как `Promise.all(..)`
    var msgs = yield ASQ().all(
        request( "http://some.url.1?v=" + value1 ),
        request( "http://some.url.2?v=" + value2 ),
        request( "http://some.url.3?v=" + value3 )
    );

    // отправляем сообщение на следующий шаг
    yield (msgs[0] + msgs[1] + msgs[2]);
} )

// отправляем окончательный результат предыдущего генератора
// на следующий запрос
.seq( function(msg){
    return request( "http://some.url.4?msg=" + msg );
} )

// теперь мы наконец закончили!
.val( function(result){
    console.log( result ); // всё выполнено успешно!
} )

// или у нас была какая-то ошибка!
.or( function(err) {
    console.log( "Error: " + err );
} );
```

Утилита `runner(...)` получает (необязательные) сообщения для запуска генератора, которые исходят из предыдущего шага последовательности и доступны в генераторе в массиве `token.messages`.

Затем, подобно тому, что мы продемонстрировали выше с помощью функции `runGenerator(...)`, `runner(...)` прослушивает либо полученный промис, либо полученную последовательность *asynquence* (в данном случае последовательность `ASQ().all(...)` «параллельных» шагов) и ждёт, пока он завершит работу для возобновления генератора.

Когда генератор завершается, окончательное значение, которое он отдаёт, передаётся на следующий шаг последовательности.

Более того, если какая-либо ошибка произойдёт в любом месте этой последовательности, даже внутри генератора, она распространится до зарегистрированного с помощью `or(...)` обработчика ошибки.

*asynquence* пытается сделать связь промисов и генераторов настолько прочной, насколько это возможно. У вас есть свобода подключать любые потоки генератора наряду с потоками последовательности на основе промисов, какие вы сочтёте нужным.

## Асинхронные функции ES7

Существует предложение для ES7, которое скорее всего будет принято, добавляющее новый тип функций: асинхронные функции. Такая функция выглядит как генератор, автоматически обёрнутый в утилиту вроде `runGenerator(...)` (или `runner(...)` из *asynquence*). Таким образом, вы можете посылать промис, а асинхронная функция автоматически свяжется с ним, чтобы продолжить своё выполнение после завершения промиса (даже нет необходимости возиться с итераторами!).

Вероятно, это будет выглядеть так:

```js
async function main() {
    var result1 = await request( "http://some.url.1" );
    var data = JSON.parse( result1 );

    var result2 = await request( "http://some.url.2?id=" + data.id );
    var resp = JSON.parse( result2 );
    console.log( "The value you asked for: " + resp.value );
}

main();
```

Как видите, асинхронную функцию можно вызвать напрямую (как `main()`) без необходимости оборачивать её во вспомогательную функцию вроде `runGenerator(...)` или `ASQ().runner(...)`. Внутри вместо `yield` используется `await` (ещё одно новое ключевое слово), которое говорит асинхронной функции, что в этом месте нужно подождать завершение промиса прежде чем продолжить работу.

В принципе, у нас будет большая часть возможностей генераторов, обернутых вспомогательной библиотекой, но они будут **напрямую поддерживаться нативным синтаксисом**.

Здорово, да!?

В то же время библиотеки, такие как *asynquence*, дают нам вспомогательные утилиты, чтобы максимально использовать наши асинхронные генераторы!

## Заключение

Проще говоря, комбинация генератор + промис сочетает в себе лучшее из обоих миров и даёт мощные и элегантные возможности выражать асинхронные потоки, которые выглядят как синхронные. С помощью простой вспомогательной обёртки (которую предоставляют многие библиотеки), мы можем автоматически запускать генератор при завершении промиса, при этом обрабатывать ошибки как в синхронном коде!

А в ES7+ мы, вероятно, увидим асинхронные функции, которые позволят нам делать это даже без вспомогательной утилиты (по крайней мере, для базовых случаев)!

**Будущее асинхронности в JavaScript яркое**, и становится только ярче! Мне нужно носить солнечные очки.

Но это ещё не конец. Есть один последний горизонт, который мы хотим исследовать:

Что если мы могли бы объединить два или более генераторов вместе, позволить им работать независимо, но «параллельно», и отправлять сообщения туда и обратно по мере их выполнения? Это была бы какая-то супер мощная возможность, не так ли!?! Этот шаблон называется «CSP» (communicating sequential processes / взаимодействующие последовательные процессы). Мы рассмотрим возможности CSP в следующей статье. Следите!
