# Разбираемся с генераторами в JavaScript ES6 на примерах

*Перевод статьи Arfat Salman: [Understanding Generators in ES6 JavaScript with Examples](https://codeburst.io/understanding-generators-in-es6-javascript-with-examples-6728834016d5)*

*Дата публикации: 23.04.2018*

В ES6 появился новый способ работать с функциями и итераторами в форме **генераторов (или функций-генераторов)**. Генератор — это функция, которая **может остановиться на полпути**, а затем продолжить выполнение с того места, где она остановилась. **Короче говоря, генератор выглядит как функция, но ведёт себя как итератор**.

**Любопытный факт**: `async/await` основаны на генераторах. Подробнее можно почитать [здесь](https://tc39.github.io/ecmascript-asyncawait/).

Генераторы неразрывно связаны с итераторами. Если вы не знаете о них, [здесь](https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e) статья, которая поможет лучше их понять.

Вот простая аналогия, которая даст вам интуитивное представление о генераторах, прежде чем мы перейдём к техническим деталям.

Представьте, что вы читаете захватывающий техно-триллер. Вы поглощены страницами книги и едва слышите звонок в дверь. Это парень из доставки пиццы. Вы встаёте, чтобы открыть дверь. **Но перед этим вы оставляете закладку на последней прочитанной странице.** Вы мысленно сохраняете события сюжета. А после этого вы пойдёте и получите свою пиццу. Вернувшись в комнату, вы продолжите чтение *с той страницы, на которой оставили закладку*. Вы не начнёте снова с первой страницы. В некотором смысле вы действуете как функция-генератор.

## Введение

Давайте посмотрим, как мы можем использовать генераторы для решения некоторых распространённых проблем программирования. Но сначала определим, что такое генераторы.

### Что такое генераторы?

Обычную функцию, такую как эта, нельзя остановить *до того*, как она завершит свою задачу, то есть пока её последняя строка не будет выполнена. Такая модель называется ][run-to-completion](https://en.wikipedia.org/wiki/Run_to_completion_scheduling) (выполняйся-до-завершения).

```js
function normalFunc() {
  console.log('I')
  console.log('cannot')
  console.log('be')
  console.log('stopped.')
}
```

Единственные способы выйти из `normalFunc`: вернуть значение с помощью `return` или выбросить ошибку. Если вы вызовёте функцию снова, она начнёт выполняться **сначала**.

В противоположность этому, генератор — это функция, которая может **остановиться на полпути** и продолжить выполнение *с того места, где она была остановлена*.

Вот некоторые другие определения генераторов —

- Генераторы — это специальный класс функций, которые упрощают задачу написания итераторов. 
- Генератор — это функция, которая производит последовательность результатов вместо одного значения, т.е. *генерирует* серию значений.

В JavaScript генератор — это функция, возвращающая объект, у которого вы можете вызвать метод `next()`. Каждый вызов `next()` будет возвращать объект такого вида — 

```js
{ 
  value: Any,
  done: true|false
} 
```

Свойство `value` будет содержать значение. Свойство `done` может принимать значение `true` или `false`. Когда свойство `done` становится равным `true`, генератор останавливается и не генерирует больше никаких значений.

Вот иллюстрация этого процесса — 

![Обычные функции против генераторов](images/understanding_generators_in_es6_javascript_with_examples-1.png "Обычные функции против генераторов")

Обратите внимание на пунктирную стрелку, которая замыкает цикл **yield-resume-yield** перед **Finish**. **Это возможность создавать бесконечные генераторы.** Мы рассмотрим примеры позже.

### Создание генератора

Посмотрим, как мы может создать генератор в JavaScript — 

<pre>
<b>function *</b> generatorFunction() { // Строка 1
  console.log('Эта строка будет выполнена первой.');
  <b>yield</b> 'Привет, ';   // Строка 2

  console.log('Я буду напечатана после паузы.');  
  <b>yield</b> 'Мир!';
}

const <b>generatorObject</b> = generatorFunction(); // Строка 3

console.log(<b>generatorObject.next()</b>.value); // Строка 4
console.log(<b>generatorObject.next()</b>.value); // Строка 5
console.log(<b>generatorObject.next()</b>.value); // Строка 6

// Эта строка будет выполнена первой.
// Привет, 
// Я буду напечатана после паузы.
// Мир!
// undefined
</pre>

Обратите внимание на участки, выделенные жирным. Для создания функции-генератора мы используем синтаксис `function *` вместо просто `function`. Между ключевым словом `function`, звёздочкой `*` и именем функции может быть любое количество пробелов. Поскольку это просто функция, вы можете использовать её везде, где может использоваться функция, например, внутри объектов или в качестве методов класса.

В теле функции в примере нет `return`. Вместо этого мы используем другое ключевое слово — `yield` (Строка 2). Это оператор, с помощью которого генератор может останавливать сам себя. Каждый раз, когда генератор встречает `yield`, он “возвращает” значение, определённое после `yield`. В нашем примере возвращается `Привет, `. Однако в контексте генераторов мы не говорим “вернул”. Мы говорим “генератор **отдал** `Привет, `”.

Мы также можем вернуть значение из генератора. Однако `return` устанавливает свойство `done` в true, после чего генератор больше не может генерировать значения.

```js
function *  generatorFunc() {
  yield 'a';
  return 'b'; // Генератор завершается здесь.
  yield 'a';  // Никогда не будет выполнена. 
}
```

В строке 3 мы создаём объект-генератор. **Выглядит так, как будто мы вызываем** функцию `generatorFunction`. Так и есть! Разница в том, что вместо любого значения функция-генератор *всегда* возвращает объект-генератор. Объект-генератор — это итератор. Так что вы можете использовать его в цикле `for-of` или в других конструкциях, работающих с итераторами.

В строке 4 мы вызываем метод `next()` у объекта `generatorObject`. После этого вызова начинается выполнение генератора. Во-первых, `console.log` выводит строку `Эта строка будет выполнена первой.`. Затем встречается `yield 'Привет, '`. Генератор отдаёт значение в виде объекта `{ value: 'Привет, ', done: false }` и засыпает/приостанавливается. Теперь он ждёт следующий вызов.

В строке 5 мы снова вызываем `next()`. В этот момент генератор просыпается и начинает выполнение с того момента, где он остановился. На следующей строке он находит `console.log` и выводит строку `Я буду напечатана после паузы.`. Встречается другой `yield`. Генератор отдаёт значение в виде объекта `{ value: 'Мир!', done: false }`. Мы извлекаем значение и выводим его в консоль. Генератор снова засыпает.

В строке 6 мы снова вызываем `next()`. На этот момент больше не осталось строк для выполнения. Напомню, что каждая функция неявно возвращает `undefined`, если в ней нет выражения `return`. Соответственно, генератор возвращает (а не отдаёт) объект `{ value: undefined, done: true}`. Свойство `done` установлено в `true`. Это сигнализирует о конце генератора. Теперь он больше не может генерировать значения или возобновиться, т.к. не осталось выражений для выполнения.

Нам нужно создать новый объект-генератор, что снова запустить генератор.

## Использование генераторов

Есть много крутых вариантов использования генераторов. Давайте рассмотрим некоторые из них.

### Реализация итерируемых объектов

Когда вы реализуете итератор, вам нужно вручную создать объект-итератор с методом `next()`. Также вы должны вручную сохранить состояние. Часто это бывает сложно сделать. Поскольку генераторы — это также итераторы, они могут использоваться для реализации итерируемых объектов без дополнительного кода. Давайте рассмотрим простой пример.

*Проблема: Мы хотим создать собственный итерируемый объект, который будет возвращать `Это `, `итерируемый ` и `объект.`. Вот одна реализация с помощью итераторов —*

```js
const iterableObj = {
  [Symbol.iterator]() {
    let step = 0;
    return {
      next() {
        step++;
        if (step === 1) {
          return { value: 'Это ', done: false};
        } else if (step === 2) {
          return { value: 'итерируемый ', done: false};
        } else if (step === 3) {
          return { value: 'объект.', done: false};
        }
        return { value: '', done: true };
      }
    }
  },
}

for (const val of iterableObj) {
  console.log(val);
}

// Это
// итерируемый 
// объект.
```

А вот так же самая вещь с использованием генераторов — 

```js
function * iterableObj() {
  yield 'Это ';
  yield 'итерируемый ';
  yield 'объект.'
}

for (const val of iterableObj()) {
  console.log(val);
}

// Это
// итерируемый 
// объект.
```

Вы можете сравнить обе версии. Да, это надуманный пример. Но он иллюстрирует следующее —

- Нам не нужно беспокоиться о `Symbol.iterator`.
- Нам не нужно реализовывать метод `next()`.
- Нам не нужно вручную создавать объект, который вернёт метод `next()`, т.е. `{ value: 'Это ', done: false }`.
- Нам не нужно сохранять состояние. В примере с итератором состояние сохраняется в переменную `step`. От значения этой переменной зависит значение, которое отдаётся итератором. В случае с генератором нам не нужно делать ничего из этого.

### Улучшенная асинхронная функциональность

Код, использующий промисы и функции обратного вызова, такой как — 

```js
function fetchJson(url) {
    return fetch(url)
    .then(request => request.text())
    .then(text => {
        return JSON.parse(text);
    })
    .catch(error => {
        console.log(`ERROR: ${error.stack}`);
    });
}
```

можно переписать так (с помощью библиотеки, такой как [co.js](https://github.com/tj/co)) — 

```js
const fetchJson = co.wrap(function * (url) {
    try {
        let request = yield fetch(url);
        let text = yield request.text();
        return JSON.parse(text);
    }
    catch (error) {
        console.log(`ERROR: ${error.stack}`);
    }
});
```

Некоторые читатели возможно заметили сходство с использованием `async/await`. Это не совпадение. Асинхронные функции (`async/await`) используют похожую стратегию и заменяют `yield` на `await`, если речь идёт о промисах. Они основаны на генераторах.

### Бесконечные потоки данных

Возможно создавать генераторы, которые никогда не заканчиваются. Рассмотрим этот пример —

```js
function * naturalNumbers() {
  let num = 1;
  while (true) {
    yield num;
    num = num + 1
  }
}

const numbers = naturalNumbers();

console.log(numbers.next().value)
console.log(numbers.next().value)

// 1
// 2
```

Мы создали генератор `naturalNumbers`. Внутри функции у нас есть бесконечный цикл `while`. В этом цикле мы отдаём значение `num`. Когда генератор отдаёт значение, он засыпает. Когда мы снова вызываем метод `next()`, генератор просыпается, продолжает выполнение с того момента, где он был остановлен (в данном случае `yield num`) и выполняется до тех пор, пока не встретится следующее `yield` или пока генератор не будет завершён. Поскольку следующее выражение — `num = num + 1`, оно обновляет значение `num`. Затем выполнение переходит к началу цикла. Условие равно `true`. Встречается следующая строка `yield num`. Генератор отдаёт значение и засыпает. Это может продолжаться столько, сколько хотите.

### Генераторы как наблюдатели

Генераторы также могут получать значения с помощью метода `next(val)`. В этом случае генератор называют наблюдателем, так как он просыпается, когда получает новые значения. В некотором смысле, он продолжает наблюдать за значениями и выполняет действия, когда получает их. [Здесь](http://exploringjs.com/es6/ch_generators.html#sec_generators-as-observers) вы можете узнать больше об этом шаблоне.

## Преимущества генераторов

### Ленивое выполнение

Как видно из примера **Бесконечные потоки данных**, он возможен только благодаря ленивому выполнению. Ленивое выполнение (Lazy Evaluation) — это модель, которая задерживает выполнение выражения до тех пор, пока не понадобится его значение. То есть, если нам не нужно значение, оно не существует. Оно вычисляется по мере необходимости. Давайте посмотрим пример —

```js
function * powerSeries(number, power) {
  let base = number;
  while(true) {
    yield Math.pow(base, power);
    base++;
  }
}
```

Генератор `powerSeries` отдаёт ряд чисел, возведённых в степень. Например, степенной ряд с базой 3 и степенью 2 — **9(3²) 16(4²) 25(5²) 36(6²) 49(7²)**. Когда мы делаем `const powersOf2 = powerSeries(3, 2);`, мы просто создаём объект-генератор. Ни одно значение не вычисляется. А если мы вызовем `next()`, значение 9 вычислится и вернётся.

### Эффективность по памяти

Прямое следствие ленивого выполнения — генераторы эффективны по памяти. Мы генерируем только одно необходимое значение. В обычных функциях нам нужно генерировать все значения и хранить их на случай, если они понадобятся позже. Но с генераторами мы можем отложить вычисление, пока оно не потребуется.

Мы можем создавать функции-комбинаторы для работы с генераторами. Комбинаторы — это функции, которые объединяют существующие итерируемые объекты для создания новых. Один из таких комбинаторов — `take`. Он берет первые `n` элементов итерируемой последовательности. Вот пример реализации — 

```js
function * take(n, iter) {
  let index = 0;
  for (const val of iter) {
    if (index >= n) {
      return;
    }
    index = index + 1;
    yield val;
  }
}
```

А вот некоторые интересные варианты использования `take` —

```js
take(3, ['a', 'b', 'c', 'd', 'e'])

// a b c

take(7, naturalNumbers());

// 1 2 3 4 5 6 7

take(5, powerSeries(3, 2));

// 9 16 25 36 49
```

Здесь показана реализация библиотеки [cycled](https://github.com/sindresorhus/cycled) (без функциональности вывода в обратном порядке).

```js
function * cycled(iter) {
  const arrOfValues = [...iter]
  while (true) {
    for (const val of arrOfValues) {
      yield val
    }
  }
}

console.log(...take(10, cycled(take(3, naturalNumbers()))))

// 1 2 3 1 2 3 1 2 3 1
```

### Предостережения

Есть некоторые моменты, о которых вы должны помнить при работе с генераторами.

- **Генераторы — это разовый доступ.** Если вы перебрали все значения, вы не сможете получить их снова. Чтобы снова генерировать значения, необходимо создать новый объект-генератор.

<pre>
const numbers = naturalNumbers();

console.log(...take(10, numbers)) // 1 2 3 4 5 6 7 8 9 10
<b>console.log(...take(10, numbers))</b> // Это не даст никаких данных
</pre>

- Генераторы не предоставляют случайный доступ к элементам как в массиве. Поскольку значения генерируются одно за другим, для доступа к случайному значению нужно вычислить все значения до этого элемента. Следовательно, это не случайный доступ.

## Заключение

Ещё многое можно рассмотреть в теме генераторов, например, `yield *`, `return()` и `throw()`. Генераторы также позволяют реализовывать [сопрограммы](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0). Я перечислил несколько ссылок, по которым вы можете получить дополнительную информацию.

Вы можете перейти на страницу модуля [itertools](https://docs.python.org/2/library/itertools.html#itertools.chain) для Python и посмотреть некоторые из утилит, которые позволяют работать с итераторами и генераторами. В качестве упражнения вы можете реализовать утилиты самостоятельно.

### Ссылки

- [PEP 255](https://www.python.org/dev/peps/pep-0255/) — Предложение для генераторов в Python. Но обоснование применимо и к JavaScript.
- [Mozilla Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
- Углублённая серия из четырёх частей [Кайла Симпсона](https://medium.com/@getify) о генераторах и сопрограммах. Можно прочитать [здесь](https://davidwalsh.name/es6-generators).
- Углублённый обзор генераторов от [Акселя Раушмайера](https://medium.com/@rauschma). Можно прочитать [здесь](http://exploringjs.com/es6/ch_generators.html).
- [Модуль itertools для Python](https://docs.python.org/2/library/itertools.html#itertools.chain) — Встроенная в Python библиотека, которая содержит множество утилит для работы с генераторами и итераторами.
