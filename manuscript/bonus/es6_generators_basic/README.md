# Основы генераторов ES6 {#es6_generators_basic}

*Перевод статьи Kyle Simpson: [The Basics Of ES6 Generators](https://davidwalsh.name/es6-generators)*

*Дата публикации: 21.07.2014*

## Генераторы ES6: Полная серия

1. [Основы генераторов ES6](#es6_generators_basic)
2. [Глубокое погружение в генераторы ES6](#es6_generators_dive)
3. [Асинхронность с генераторами ES6](#async_generators)
4. [Параллелизм с генераторами ES6](#concurrent_generators)

Одна из самых захватывающих новых возможностей в JavaScript ES6 — это новый тип функций, который называется **генераторами**. Название немного странное, но их поведение, на первый взгляд, может показаться *ещё более странным*. Эта статья рассказывает об основах работы генераторов и формирует понимание, почему они настолько важны для будущего JS.

## Выполнение до завершения (Run-To-Completion)

Первое, что нужно пронаблюдать, когда мы говорим о генераторах, — это то, как они отличаются от обычных функций относительно правила «выполняйся до завершения».

Независимо от того, осознали вы это или нет, вы всегда могли быть уверены в одной фундаментальной вещи касательно ваших функций: если функция начала выполнение, она всегда выполнится до завершения прежде, чем сможет запуститься любой другой JS-код.

Пример:

```js
setTimeout(function () {
    console.log("Привет, мир");
}, 1);

function foo() {
    // Внимание: никогда не делайте такие безумные долго выполняющиеся циклы
    for (var i = 0; i <= 1E10; i++) {
        console.log(i);
    }
}

foo();
// 0..1E10
// "Привет, мир"
```

Здесь цикл `for` займёт довольно много времени: больше, чем одну секунду, но колбэк таймера с выражением `console.log(...)` не может прервать функцию `foo()`, пока она запущена. Поэтому он застрянет в очереди задач и будет терпеливо ждать. 

А что если функция `foo()` могла бы быть прервана? Разве это не привело бы к хаосу в наших программах?

Это ~~кошмар~~ проблемы многопоточного программирования, но нам очень повезло в мире JavaScript. Мы можем не волноваться насчёт этого, потому что JS всегда выполняется в одном потоке (только одна команда/функция выполняется в любой момент времени).

**Примечание:** веб-воркеры — это механизм, который позволяет для части JS-программы создать отдельный поток, параллельный основному потоку программы. Это не приводит к многопоточным усложнениям, потому что эти два потока могут взаимодействовать друг с другом только через обычные асинхронные события, которые всегда соблюдают однопоточное поведение событийного цикла.

## Выполняйся...Остановись...Выполняйся

С генераторами ES6 у нас есть другой тип функций, которые можно *приостановить* в середине, а *позже* один или несколько раз возобновить, позволяя другому коду выполняться в течение этих периодов паузы.

Если вы когда-либо читали что-то о параллелизме или программировании на основе потоков, возможно, вы видели термин «совместный» («cooperative»). Он в основном указывает, что сам процесс (в нашем случае, функция) выбирает, когда его можно прерывать, чтобы он мог взаимодействовать с другим кодом. Эта концепция противоположна «вытесняющей» («preemptive»), которая предполагает, что процесс/функция может быть прервана против её воли.

Функции-генераторы ES6 являются «совместными» в их параллельном поведении. Внутри тела функции-генератора вы используете новое ключевое слово `yield`, чтобы приостановить функцию изнутри. Ничто не может приостановить генератор снаружи; он останавливается, когда встречает `yield`.

Однако, как только генератор приостановил себя, он не может возобновиться сам по себе. Для перезапуска генератора необходимо использовать внешний элемент управления. Мы объясним, как это происходит через мгновение.

Таким образом, в принципе, функция-генератор может останавливаться и перезапускаться столько раз, сколько вы захотите. Фактически, вы можете создать функцию-генератор с бесконечным циклом (например, с печально известным `while (true) {..}`), которая, по сути, никогда не заканчивается. Хотя это безумие или ошибка в обычной JS-программе, в функции-генераторе это совершенно нормально, а иногда и то, что нужно!

Ещё важнее то, что остановка и запуск — это не *просто* контроль над выполнением функции-генератора, но и двухсторонний обмен сообщениями по мере её выполнения. В случае обычной функции вы получаете параметры в начале и возвращаете значение в конце. С функциями-генераторами вы посылаете сообщения наружу с каждым `yield`, и отправляете сообщения обратно при каждом перезапуске.

## Синтаксис, пожалуйста!

Давайте рассмотрим синтаксис этих новых интересных функций-генераторов.

Во-первых, новый синтаксис объявления:

```js
function *foo() {
    // ..
}
```

Обратили внимание на символ `*`? Он выглядит ново и немного странно. По аналогии с некоторыми другими языками, он может показаться чем-то ужасным, как указатель на возвращаемое функцией значение. Но не смущайтесь! Это всего лишь способ определить специальный тип функций-генераторов.

Вы, вероятно, видели другие статьи/документацию, где используется `function* foo(){ }` вместо `function *foo(){ }` (разница в том, где находится `*`). Оба эти варианта правильные, но я недавно решил, что вариант `function *foo(){ }` более точный, поэтому использую его в этой статье.

Теперь давайте поговорим о содержимом нашей функции-генератора. Функция-генератор — это во многом обычная JS-функция. *Внутри* функции-генератора очень мало нового синтаксиса.

Как упоминалось выше, главная новая игрушка, с которой мы можем играть — это ключевое слово `yield`. `yield ___` называется «выражением yield» (а не оператором), потому что когда мы возобновляем выполнение генератора, мы отправляем в него значение, и это значение становится результатом выражения `yield ___`.

Пример:

```js
function *foo() {
    var x = 1 + (yield "foo");
    console.log(x);
}
```

Выражение `yield "foo"` отправит значение `"foo"` из генератора, когда функция-генератор остановится в этой точке. А когда (и если) генератор возобновится, переданное значение станет значением этого выражения. Это значение будет прибавлено к `1`, а результат присвоен в переменную `x`.

Видите двухстороннюю коммуникацию? Генератор отправляет значение `"foo"` наружу, останавливая себя, и когда-нибудь *позже* (возможно немедленно, возможно спустя долгое время) генератор будет возобновлён и получит значение обратно. Почти как если бы ключевое слово `yield` делало запрос на получение значения.

Вы *можете* использовать `yield` самостоятельно в любом месте, в этом случае предполагается значение `undefined`. Пример:

```js
// Внимание: функция `foo(..)` здесь - это НЕ генератор!!
function foo(x) {
    console.log("x: " + x);
}

function *bar() {
    yield; // просто пауза
    foo(yield); // ожидает параметр, чтобы передать в `foo(..)`
}
```

## Итератор генератора

«Итератор генератора». Труднопроизносимое выражение, не так ли?

Итераторы — это шаблон проектирования, где мы последовательно отдаём упорядоченный набор значений по одному за раз при каждом вызове `next()`. Представьте себе для примера использование итератора с массивом, который имеет пять значений: `[1, 2, 3, 4, 5]`. Первый вызов `next()` вернёт `1`, второй вызов вернёт `2` и т.д. Когда вернутся все значения, `next()` будет возвращать `null`, `false` или какое-то другое значение, сигнализирующее, что итератор перебрал все элементы источника данных.

С помощью *итератора генератора* мы управляем функцией-генератором извне. Это звучит намного сложнее, чем есть на самом деле. Рассмотрим этот простой пример:

```js
function *foo() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
}
```

Чтобы пройтись по значениям функции-генератора `*foo()`, нам нужно создать итератор. Как это сделать? Легко!

```js
var it = foo();
```

Ах! Получается, вызов функции-генератора обычным способом не выполняет тело функции.

Это немного странно. Вы можете быть удивлены, почему не `var it = new foo()`. Ответственность за синтаксис — это сложный вопрос и лежит за рамками нашего обсуждения в этой статье.

Итак, теперь, чтобы начать итерировать нашу функцию-генератор, мы просто делаем:

```js
var message = it.next();
```

Вызов `next()` отдаст значение `1` из выражения `yield 1`, но это не единственное, что мы получаем.

```js
console.log(message); // { value:1, done:false }
```

На самом деле, при каждом вызове `next()` мы получаем объект, который имеет свойство `value` для отданного значения и свойство `done` — логическое значение, показывающее, завершилась функция-генератор или нет.

Давайте продолжим итерацию:

```js
console.log(it.next()); // { value:2, done:false }
console.log(it.next()); // { value:3, done:false }
console.log(it.next()); // { value:4, done:false }
console.log(it.next()); // { value:5, done:false }
```

Обратите внимание, что `done` всё ещё равно `false`, когда мы получили значение `5`. Это потому что *технически* функция-генератор ещё не завершена. Мы всё ещё можем вызвать финальный `next()`, и если передадим значение, оно станет результатом выражения `yield 5`. Только тогда функция-генератор завершится. 

Итак, теперь:

```js
console.log(it.next()); // { value:undefined, done:true }
```

В итоге, функция-генератор завершилась, но с `undefined` в качестве результата (поскольку мы уже исчерпали все выражения `yield ___`).

В этот момент вы можете заинтересоваться, можно ли использовать `return` в функции-генераторе, и если да, то это значение будет отправлено в свойстве `value`?

**Да...**

```js
function *foo() {
    yield 1;
    return 2;
}

var it = foo();

console.log(it.next()); // { value:1, done:false }
console.log(it.next()); // { value:2, done:true }
```

**... и нет.**

Полагаться на возвращаемое из генератора значение — это не очень хорошая идея, потому что когда функции-генераторы итерируются в циклах `for...of` (смотрите ниже), последнее значение отбрасывается.

Для полноты картины давайте рассмотрим отправку сообщений как в функцию-генератор, так и из неё:

```js
function *foo(x) {
    var y = 2 * (yield (x + 1));
    var z = yield (y / 3);
    return (x + y + z);
}

var it = foo(5);

// внимание: здесь ничего не отправляется в `next()`
console.log(it.next());       // { value:6, done:false }
console.log(it.next(12));   // { value:8, done:false }
console.log(it.next(13));   // { value:42, done:true }
```

Как видите, мы можем передать начальные параметры (в нашем случае `x`) в момент инициализации итератора `foo(5)` так же, как параметры обычной функции.

В первом вызове `next(...)` мы ничего не передаём. Почему? Потому что в этот момент нет выражения `yield`, чтобы принять переданное значение.

Если мы всё же *передадим* значение в первый вызов `next(...)`, ничего не произойдёт. Это значение будет просто отброшено. Стандарт ES6 говорит, что в этом случае функции-генераторы просто игнорируют неиспользуемые значения. (**Примечание:** на момент написания статьи, в Хром и Файрфокс это работает, но другие браузеры, возможно, ещё не полностью совместимы и могут вызвать ошибку в этом случае).

Выражение `yield (x + 1)` отправляет наружу значение `6`. Второй вызов `next(12)` посылает `12` в качестве значения выражения `yield (x + 1)`, поэтому `y` принимает значение `12 * 2`, т.е. `24`. Затем выражение `yield (y / 3)` (`yield (24 / 3)`) отдаёт наружу значение `8`. Третий вызов `next(13)` посылает `13` в качестве значения выражения `yield (y / 3)`, в результате `z` становится равным `13`.

Наконец, `return (x + y + z)` — это `return (5 + 24 + 13)`, т.е. `42` вернётся в качестве последнего значения.

**Перечитайте это несколько раз.** Для большинства поначалу это выглядит странно.

## for..of

ES6 также поддерживает шаблон итератор на синтаксическом уровне, предоставляя возможность для запуска итераторов до завершения: цикл `for...of`.

Пример:

```js
function *foo() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
    yield 5;
    return 6;
}

for (var v of foo()) {
    console.log(v);
}
// 1 2 3 4 5

console.log(v); // всё ещё `5`, в не `6` :(
```

Как видите, цикл `for...of` автоматически подхватывает итератор, созданный функцией `foo()`, и проходит по всем значениям, пока не достигнет `done: true`. Пока свойство `done` равно `false`, он автоматически извлекает значение свойства `value` и присваивает его в переменную цикла (в нашем случае `v`). Как только свойство `done` станет равным `true`, цикл прекращается (финальное значение `value` игнорируется).

Как упоминалось выше, вы можете видеть, что цикл `for...of` игнорирует и отбрасывает значение выражения `return 6`. Кроме того, поскольку в этом примере нет явного вызова `next()`, цикл `for...of` не может использоваться в ситуациях, когда нужно передать значения в функцию-генератор, как мы это делали выше.

## Заключение

Хорошо, это было введение в генераторы. Не волнуйтесь, если не всё ещё понятно. Мы все поначалу так чувствовали себя!

Это естественно удивляться, как такая экзотическая игрушка может использоваться на практике в вашем коде. Но мы лишь затронули малую часть, есть ещё моменты, которые стоит рассмотреть. Поэтому мы копнём глубже в изучение генераторов, прежде чем обнаружим, насколько мощными они могут быть на практике.

После того, как вы наиграетесь с примерами, у вас могут возникнуть следующие вопросы:

- Как работает обработка ошибок?
- Может ли генератор вызвать другой генератор?
- Как асинхронный код работает с генераторами?

Эти и другие вопросы мы рассмотрим в следующей статье, оставайтесь на связи!
