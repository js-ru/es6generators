# Генераторы ES6: как они работают?

*Перевод статьи Josh Johnston: [ES6 Generators: How do They Work?](https://x-team.com/blog/generators-work/)*

*Дата публикации: 28.04.2015*

Написать программное обеспечение, которое даёт правильный результат, может быть сложно. Но мы все знаем, что это только начало настоящих испытаний. От того, насколько правильный способ выбран для решения той или иной задачи, зависит, будет ли работа “иметь смысл” и приносить удовольствие или закончится чем-то подобным в комментарии:

```js
//
// Дорогой мейнтейнер:
//
// Когда ты закончишь попытки 'оптимизировать' эту рутину,
// и осознаешь, какая это была ужасная ошибка,
// пожалуйста, увеличь следующий счетчик в качестве предупреждения
// для следующего парня:
//
// total_hours_wasted_here = 42
//
```

(источник: [http://stackoverflow.com/questions/184618/what-is-the-best-comment-in-source-code-you-have-ever-encountered/482129#482129](http://stackoverflow.com/questions/184618/what-is-the-best-comment-in-source-code-you-have-ever-encountered/482129#482129))

Сегодня мы рассмотрим, как работают [генераторы ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) под капотом, чтобы лучше понять, как мы можем использовать их для решения старых проблем по-новому.

## Не блокируй

Возможно, вы слышали о важности написания «неблокирующего» JavaScript. Когда мы выполняем операцию ввода-вывода, например, делаем HTTP-запрос или пишем в базу данных, мы обычно хотим использовать что-то вроде функций обратного вызова или обещаний (промисов). Выполнение «блокирующей» операции может привести к тому, что всё приложение будет заморожено, а это в большинстве случаев неприемлемо. Представьте, что все ваши пользователи будут сидеть и ждать каждый раз, когда кто-то другой взаимодействует с системой.

Другое следствие этого: если JavaScript-программа когда-нибудь входит в бесконечный цикл, всё замирает. Запуск `node -e 'while(true) {}`, возможно, заморозит ваш компьютер и потребует перезагрузки. Возможно, не пробуйте этого дома (⚆ _ ⚆).

Учитывая всё это, любопытно слышать, что генераторы ES6 позволяют нам эффективно «приостанавливать» выполнение в середине функции и возобновлять её в будущем. Существует также множество примеров генераторов, щеголяющих своими бесконечными циклами в непринуждённой манере «просто бесконечный цикл, подумаешь». На первый взгляд можно подумать подумать, что для реализации такого поведения потребуется существенная перестройка платформы. Однако с такими инструментами, как [Regenerator](https://facebook.github.io/regenerator/) и [Babel](https://babeljs.io/), эта функциональность легко доступна для нас в простом старом ES5. Вы когда-нибудь задумывались о том, какие древние ритуалы делают это возможным? Сегодня мы это выясним. Надеюсь, мы также уйдем с более глубоким пониманием того, как работают генераторы и как их использовать максимально эффективно.

Прежде, чем мы начнём: если вы новичок в генераторах, я рекомендую [воркшоп на nodeschool](http://nodeschool.io/#workshoppers) в качестве прекрасного практического учебника, который поможет вам разобраться в общих чертах. Просто выполните команду `npm install -g learn-generators` и затем запустите с помощью `learn-generators`. Также вы можете [скачать его с GitHub](https://github.com/isRuslan/learn-generators):

![Learn Generators](images/generators_work.webp "Learn Generators")

## Ленивая последовательность

Давайте начнём с простого примера. Представьте, что вам нужно что-то сделать с последовательностью значений. Вы можете реализовать её в виде массива и управлять этими значениями. Но что, если эта последовательность бесконечной длины? Массивы здесь не подойдут. Вместо этого мы можем реализовать последовательность в виде функции-генератора:

```js
function* generateRandoms (max) {
  max = max || 1;

  while (true) {
    let newMax = yield Math.random() * max;
    if (newMax !== undefined) {
      max = newMax;
    }
  }
}
```

Обратите внимание на ключевое слово `function*`, которое показывает, что это специальная «функция-генератор» и она будет вести себя отлично от обычной функции. Другая важная часть — ключевое слово `yield` в строке 5. Обычные функции могут вернуть значение только с помощью `return`, при этом выполнение функции завершается. Функции-генераторы могут отдавать значения когда угодно с помощью `yield`.

Мы можем интерпретировать эту функцию так: «*Каждый раз, когда у тебя спрашивают новое значение, отдавай случайное число от 0 до max. Продолжай делать это, пока программа не завершится или пока все человеческие технологии не будут уничтожены великой солнечной вспышкой в 2065. Смотря, что наступит раньше*».

Мы получаем значения от генератора, только когда запрашиваем их. Это важно, потому что в противном случае бесконечная последовательность может быстро заполнить всю доступную память. Мы запрашиваем значения с помощью итератора, который получаем, когда вызываем функцию-генератор:

```js
var iterator = generateRandoms();

console.log(iterator.next());     // { value: 0.4900301224552095, done: false }
console.log(iterator.next());     // { value: 0.8244022422935814, done: false }
```

Генераторы также позволяют двустороннюю коммуникацию как в строке 5: `let newMax = yield Math.random() * max`. Как мы увидим позже, генераторы переходят в режим «приостановлен», когда не используются, и просыпаются, когда итератор запрашивает следующее значение. Поэтому когда мы вызываем `iterator.next` и передаём значение в качестве аргумента, это значение заменяет выражение `yield Math.random() * max` и устанавливается в качестве значения `newMax`. Вы можете видеть это в действии здесь:

```js
console.log(iterator.next());     // { value: 0.4900301224552095, done: false }

// send a value to set `newMax`, which will persist for future calls to `.next()`:
console.log(iterator.next(1000)); // { value: 963.7744706124067, done: false }
console.log(iterator.next());     // { value: 714.516609441489, done: false }
```

## Генераторы в ES5

Чтобы узнать больше о том, как работают генераторы, полезно посмотреть, как они транслируются в ES5. Вы можете попробовать сами, установив babel и просмотрев исходный код, который он генерирует.

```bash
npm install -g babel

babel generate-randoms.js
```

Вот что мы получаем, когда мы запускаем это преобразование:

```js
var generateRandoms = regeneratorRuntime.mark(function generateRandoms(max) {
  var newMax;
  return regeneratorRuntime.wrap(function generateRandoms$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        max = max || 1;

      case 1:
        if (!true) {
          context$1$0.next = 8;
          break;
        }
        context$1$0.next = 4;
        return Math.random() * max;
      case 4:
        newMax = context$1$0.sent;
        if (newMax !== undefined) {
          max = newMax;
        }
        context$1$0.next = 1;
        break;
      case 8:
      case "end":
        return context$1$0.stop();
    }
  }, generateRandoms, this);
});
```

Как видите, внутренности функции-генератора были переписаны с помощью блока `switch` (начиная со строки 4). Это дает ценный ключ к пониманию её внутренней работы. Мы можем думать о генераторе, как о конечном автомате в цикле, который ведёт себя по-разному, в зависимости от того, как мы с ним взаимодействуем. Переменная `context$1$0` содержит текущее состояние, в том числе какой блок `case` выполнится следующим.

Простой способ понять этот код — сделать вид, что выражения `case` — это номера строк, а установка значения в `context$1$0.next` — это GOTO. Если, как и я, вы начинали много лет назад писать на Бейсик, я дам вам минутку, чтобы стереть слезы блаженной ностальгии, прежде чем мы продолжим.

Взгляните ещё раз на блок switch и эти условия:

- `case 0`: инициализирует значение `max` и переходит на `case 1` (строка 6).
- `case 1`: возвращает случайное значение и и делает GOTO 4 для следующего раза, когда функция возобновится (строки 13-14).
- `case 4`: проверяет значение, переданное итератором, и обновляет значение max. А затем выполняет GOTO 1, чтобы отправить обратно следующее случайное число.

Это даёт некоторое представление о том, как генератор может работать бесконечно, останавливаясь после каждого значения, и при этом соблюдать правило «не блокируй».

## Когда истина — это не истина?

Внимательные читатели заметили, что я пропустил строки 9-12:

```js
if (!true) {
    context$1$0.next = 8;
    break;
}
```

Что тут происходит? Оказывается, так был переписан оригинальный цикл `while (true)`. Конечный автомат каждый раз проверяет, дошли мы до конца или нет. В нашем примере это никогда не произойдёт, но есть много случаев, когда необходимо условие выхода из генератора. Когда оно выполняется, происходит GOTO 8, в котором генератор отключается.

## Локальное состояние для итераторов

Еще одна интересная вещь, которую мы здесь видим, заключается в том, как генератор сохраняет локальное состояние для каждого отдельного итератора. Поскольку область видимости переменной `max` ограничена замыканием `regeneratorRuntime.wrap`, её значение будет сохраняться для последующих вызовов `iterator.next()`, как было показано ранее. Если мы создадим новый итератор, вызвав `randomNumbers()`, будет создано новое замыкание. Это показывает нам, как каждый итератор может иметь своё собственное состояние, не затрагивая другие итераторы и используя тот же генератор.

## Внутри машины

Всё, что мы рассматривали ранее в блоке `switch` — это на самом деле только «фронт» конечного автомата. Вы, вероятно, обратили внимание, что функция обёрнута дважды функциями `regeneratorRuntime.mark` и `regeneratorRuntime.wrap`. Это функции из модуля [https://github.com/facebook/regenerator](https://github.com/facebook/regenerator), они определяют общий конечный автомат в ES5, который ведёт себя как функция-генератор в ES6.

В среде модуля regenerator многое происходит, но мы рассмотрим некоторые из интересных частей. Прежде всего, мы видим, что генератор начинает свою жизнь в состоянии «Suspended Start» («Приостановлен на старте») (используйте ссылку «источник» ниже, чтобы увидеть этот фрагмент кода в контексте):

```js
 function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
```

источник: [runtime.js:130,133](https://github.com/facebook/regenerator/blob/v0.8.22/runtime.js#L130-L133)

На данный момент ничего особенного не произошло – regenerator только создал функцию и вернул её. Это означает, что даже при вызове `var iterator = generateRandoms()` ничего внутри `generateRandoms` фактически не выполняется, пока мы не попросим его значение.

Когда мы вызываем метод `iterator.next()`, функция-генератор (с блоком `switch`, который мы рассматривали ранее) вызывается внутри `tryCatch`:

```js
var record = tryCatch(innerFn, self, context);
```

источник: [runtime.js:234](https://github.com/facebook/regenerator/blob/v0.8.22/runtime.js#L234)

и если результат возвращается с помощью `return` (а не `throw`), мы упаковываем результат в формат, ожидаемый итератором: `{ value, done }`. Мы также устанавливаем новое состояние: либо `GenStateCompleted`, либо `GenStateSuspendedYield`. В нашем случае, поскольку это бесконечный цикл, генератор всегда будет «приостановлен на yield».

```js
var record = tryCatch(innerFn, self, context);
if (record.type === "normal") {
    // Если из innerFn выброшено исключение, мы оставляем state ===
    // GenStateExecuting и возвращается для следующего вызова.
    state = context.done
        ? GenStateCompleted
        : GenStateSuspendedYield;

    var info = {
        value: record.arg,
        done: context.done
    };
```

источник: [runtime.js:234,245](https://github.com/facebook/regenerator/blob/v0.8.22/runtime.js#L234-L245)

## Что вы можете сделать с этим?

Сегодня мы использовали простую функцию-генератор для моделирования конечного автомата. Он создаёт потенциально бесконечную последовательность значений, которые можно лениво получать. Это поведение мы можем использовать прямо сейчас: оно уже поддерживается на современных JavaScript-платформах и легко транспилируется для остальных.

Как всегда, есть много способов достичь одной цели. В этом смысле генераторы не *необходимы*. Но если они дают нам выразительность для достижения наших намерений таким образом, что это «имеет смысл», оно того стоит. Вы нашли другие способы решения для общих проблем с использованием генераторов? Напишите мне в Twitter: [@joshwnj](https://twitter.com/joshwnj).
