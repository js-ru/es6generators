# Простой практический вариант использования генераторов ES6

## Создание бесконечного повторяющегося массива

*Перевод статьи Yash Agrawal: [A Quick, Practical Use Case for ES6 Generators](https://itnext.io/a-quick-practical-use-case-for-es6-generators-building-an-infinitely-repeating-array-49d74f555666)*

*Дата публикации: 06.06.2018*

## Предисловие

Вы, наверное, слышали о генераторах ES6 и, возможно, даже изучили синтаксис. Вам может быть интересно, для чего они действительно могут быть полезны в реальной жизни.

### Определение (c MDN)

> Генераторы являются функциями с возможностью выхода и последующего входа. Их контекст исполнения (значения переменных) сохраняется при последующих входах. — [MDN] (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/function*)

Возможно, вы думаете: «*Хорошо, но зачем мне это делать?*» Оказывается, существует целый ряд вариантов использования, от простых до сложных, многие из которых связаны с обещаниями (промисами) и асинхронными запросами (асинхронные функции с использованием async/await реализованы на базе генераторов). Моя цель — помочь вам сделать первый шаг к пониманию того, как работают генераторы, с помощью простого реального примера, чтобы вы начали замечать, когда генератор является наиболее подходящим решением в вашем собственном коде. Вот так.

## Вариант использования

Я разрабатываю приложение, в котором мои пользователи могут рассчитать трёхнедельный цикл тренировок. В приложении можно установить от 3 до 7 тренировок в неделю в течение цикла. Каждая отдельная тренировка основана на одном из четырёх упражнений: *приседания*, *жим лёжа*, *мёртвая тяга* и *упражнение на пресс*. Каждая последующая тренировка должна основываться на следующем упражнении в таком порядке:

- Приседания 
- Жим лёжа 
- Мёртвая тяга
- Упражнение на пресс
- Приседания 
- Жим лёжа 
- Мёртвая тяга
- Упражнение на пресс
- ...

Вероятно, вы такое видели.

Мне нужно сказать моему коду: «*Дай мне упражнение для следующей тренировки, затем для следующей, затем для следующей и т. д. Когда будет достигнут конец списка упражнений, начни с самого начала и продолжай повторять, пока я не сгенерирую все тренировки для трёхнедельного цикла*». Вот упрощённая версия, которую я изначально реализовал без генераторов:

```js
const lifts = ['приседания', 'жим лёжа', 'мёртвая тяга', 'пресс'];
const numWeeks = 3;
const daysPerWeek = 6;

const totalNumSessions = numWeeks * daysPerWeek;

let currentLiftIndex = 0;

// Создаёт пустой массив длинной totalNumSessions,
// и проходит по нему с помощью map
const cycle = [...Array(totalNumSessions)].map(() => ({
    lift: lifts[currentLiftIndex++ % lifts.length]
}));
```

Не *слишком* плохо, но может быть более декларативно. Было бы неплохо, если бы нам не приходилось отслеживать переменную `currentLiftIndex` непосредственно в коде генерации тренировки, не так ли? Она уменьшает читаемость кода и выглядит так, как будто принадлежит своей собственной функции. Вот код с использованием функции-генератора, который я объясню ниже.

```js
function* repeatedArray(arr) {
  let index = 0;
  while (true) {
    yield arr[index++ % arr.length];
  }
}

const lifts = ['приседания', 'жим лёжа', 'мёртвая тяга', 'пресс'];
const nextLiftGenerator = repeatedArray(lifts);

const numWeeks = 3;
const daysPerWeek = 6;

const totalNumSessions = numWeeks * daysPerWeek;

// Создаёт пустой массив длинной totalNumSessions,
// и проходит по нему с помощью map
const cycle = [...Array(totalNumSessions)].map(() => ({
  lift: nextLiftGenerator.next().value,
}));
```

Здесь код более декларативный и читаемый. Мы абстрагировали логику отслеживания индексов с помощью универсальной служебной функции `repeatedArray`. Синтаксис `function *` говорит JavaScript, что это функция-генератор. Всё, что нам нужно сделать — это попросить следующий элемент «повторяющегося» массива, и наш генератор отдаст его. А главное — **снаружи функции-генератора нам не нужно беспокоиться о том, как это происходит**.

А вот что происходит:

Функция `repeatedArray` возвращает **объект-итератор** *для самой функции repeatedArray* (прочтите это дважды), когда мы вызываем её в строке 9. Итератор хранится в переменной `nextLiftGenerator`. Важно понять, что код функции в этот момент не выполняется. Функция выполняется, только когда мы вызываем метод `next()` у итератора `nextLiftGenerator`, и только до следующего выражения `yield`. Наш генератор отдаёт значение, а потом ждёт следующий вызов, чтобы продолжить выполнение до тех пор, пока не встретит другой `yield`, а затем отдаст значение. Уловили смысл? Вот и вся суть!

Очевидно, это очень простой пример, но, надеюсь, он помог вам понять, как работают генераторы, а также почему генераторы — такая мощная особенность в JavaScript.

Если вам понравилась эта статья, подпишитесь на меня в [Twitter](https://twitter.com/ReisnerShawn) или [Instagram](https://www.instagram.com/shawn.webdev/), чтобы получить больше ботанского контента!

Хорошего кодинга!
