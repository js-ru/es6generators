# Параллелизм с генераторами ES6 {#concurrent_generators}

*Перевод статьи Kyle Simpson: [Getting Concurrent With ES6 Generators](https://davidwalsh.name/concurrent-generators)*

*Дата публикации: 12.08.2014*

## Генераторы ES6: Полная серия

1. [Основы генераторов ES6](#es6_generators_basic)
2. [Глубокое погружение в генераторы ES6](#es6_generators_dive)
3. [Асинхронность с генераторами ES6](#async_generators)
4. [Параллелизм с генераторами ES6](#concurrent_generators)

Если вы прочитали и переварили [часть 1](#es6_generators_basic), [часть 2](#es6_generators_dive) и [часть 3](#async_generators) этой серии постов, то на этом этапе вы, вероятно, чувствуете себя довольно уверенно с генераторами ES6. Надеюсь, вы вдохновились, чтобы действительно развернуть конверт и посмотреть, что вы можете с ними сделать.

Наша последняя тема для изучения может немного покрутить ваш мозг (и всё ещё скручивает мой). Не спешите, проработайте и обдумайте эти концепции и примеры. Определенно, стоит почитать другие материалы по этой теме.

Инвестиции, которые вы здесь делаете, действительно окупятся в долгосрочной перспективе. Я полностью убежден, что будущее сложных асинхронных возможностей в JS будет развиваться из этих идей.

## Формальные CSP (Communicating Sequential Processes / Взаимодействующие последовательные процессы)

Во-первых, я вдохновлён этой темой почти полностью благодаря фантастической работе [Дэвида Нолена @swannodette](http://twitter.com/swannodette). Серьезно, прочитайте всё, что он пишет по этой теме. Вот несколько ссылок, которые помогут вам начать:

- [Communicating Sequential Processes](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/)
- [ES6 Generators Deliver Go Style Concurrency](http://swannodette.github.io/2013/08/24/es6-generators-and-csp/)
- [Extracting Processes](http://swannodette.github.io/2013/07/31/extracting-processes/)

Хорошо, теперь моё исследование темы. Я пришёл в JS без формальной базы в Clojure, и у меня нет опыта работы с Go или ClojureScript. Я обнаружил, что быстро теряюсь в этой теме, и мне приходилось делать много экспериментов и предположений, чтобы извлечь полезные части.

Мне кажется, что в этом процессе я пришёл к чему-то, что имеет тот же дух и служит тем же целям, но исходит из гораздо менее формального мышления.

Я пытался упростить использование CSP API в стиле Go (и ClojureScript core.async), сохранив (надеюсь) большинство базовых возможностей. Вполне возможно, что те, кто лучше меня разбирается в этой теме, быстро заметят то, что я до сих пор пропустил в своих исследованиях. Если это так, я надеюсь, что мои исследования будут развиваться и развиваться, и я буду делиться такими откровениями с вами!

## Разбор теории CSP (небольшой)

Что такое CSP? Что значит «взаимодействующие»? «Последовательные»? Что это за «процессы»?

Прежде всего, понятие CSP пришло из книги [Тони Хоара «Взаимодействующие последовательные процессы»](http://www.usingcsp.com/). Это тяжелый теоретический материал, но если вы заинтересованы в академической стороне вещей, это лучшее место для начала. Я ни в коем случае не собираюсь заниматься этой темой эзотерическим, научным способом. Я собираюсь подойти к ней довольно неформально.

Итак, давайте начнем со слова «последовательные». Это та часть, с которой вы уже знакомы. Это еще один способ сказать об однопоточном поведении и синхронном коде, который мы получаем от генераторов ES6.

Напомню, что генераторы имеют такой синтаксис:

```js
function *main() {
    var x = yield 1;
    var y = yield x;
    var z = yield (y * 2);
}
```

Каждый из этих операторов выполняется последовательно (по порядку), по одному за раз. Ключевое слово `yield` указывает точки в коде, где может произойти блокирующая пауза (блокировка только в смысле кода генератора, а не окружающей программы!), но это ничего не меняет в отношении обработки кода сверху вниз внутри функции `*main()`. Легко, правда?

Далее, давайте поговорим о «процессах». Что это значит?

По сути, генератор действует как виртуальный «процесс». Это самостоятельная часть нашей программы, которая, если бы JavaScript позволял такие вещи, выполнялась бы полностью параллельно остальной части программы.

Вообще-то, это не совсем так. Если генератор обращается к общей памяти (то есть, если он обращается к «свободным переменным», а не только к собственным локальным переменным), он не совсем независим. Но давайте просто предположим, что на данный момент у нас есть функция-генератор, которая не имеет доступа к внешним переменным (теория функционального программирования назвала бы её «комбинатором»). Таким образом, она могла бы теоретически функционировать как самостоятельный процесс.

Но мы говорим «процессы» — во множественном числе — потому что важная часть здесь состоит в том, чтобы их было сразу два или несколько. Другими словами, два или более генератора, которые соединены вместе, сотрудничают, чтобы выполнить одну большую задачу.

Зачем разделять генераторы вместо использования одного? Самая важная причина: **разделение ответственности**. Если вы можете разбить задачу XYZ на составляющие подзадачи, такие как X, Y и Z, то реализация каждой подзадачи в своём собственном генераторе приведёт к созданию кода, который легче понять и поддерживать.

Это то же самое рассуждение, которое вы используете, когда берёте функцию `XYZ()` и разбиваете её на функции `X()`, `Y()` и `Z()`, где `X()` вызывает `Y()`, а `Y()` вызывает `Z()` и т. д. Мы разбиваем функцию на отдельные функции, чтобы упростить поддержку кода.

**То же самое мы можем сделать с несколькими генераторами.**

Наконец, «взаимодействующие». Что это значит? Это вытекает из вышесказанного — если генераторы собираются работать вместе, им нужен канал связи (не только доступ к общей лексической области видимости, а полноценный общий канал связи, к которому они будут иметь эксклюзивный доступ).

Что может передаваться по этому каналу связи? Всё, что вам нужно отправить (числа, строки и т. д.). Фактически, для связи вам даже не нужно отправлять сообщения. «Коммуникация» может быть такой же простой, как и координация — передача управления от одного генератора к другому.

Почему нужно передавать управление? Прежде всего потому, что JS является однопоточным, и буквально только один из генераторов может активно работать в любой момент. Остальные находятся в состоянии ожидания, а это означает, что они находятся в середине выполнения, но приостановлены и ожидают возобновления.

Кажется нереальным, что произвольные независимые «процессы» могут *волшебным образом* взаимодействовать и общаться. Стремление к слабой связанности замечательно, но сложно на практике.

Вместо этого кажется, что любая успешная реализация CSP представляет собой преднамеренную факторизацию существующего, хорошо известного набора логики для предметной области, где каждая часть предназначена специально для работы с другими частями.

Возможно, я совершенно в этом не прав, но я пока не вижу практического способа реализовать, чтобы две совершенно случайные функции-генератора могли быть связаны в CSP пару. Они обе должны быть разработаны для работы друг с другом, иметь общий протокол связи и т. д.

## CSP в JS

Есть несколько интересных исследований в теории CSP, применимых к JS.

У вышеупомянутого Дэвида Нолена есть несколько интересных проектов, включая [Om](https://github.com/swannodette/om), а также core.async(http://www.hakkalabs.co/articles/core-async-a-clojure-library/). Библиотека Koa(http://koajs.com/) (для node.js) имеет очень интересный подход, в первую очередь благодаря методу `use(...)`. Другая библиотека, которая очень близка к core.async / Go CSP API, — это [js-csp](https://github.com/ubolonton/js-csp).

Вам определённо стоит познакомиться с этими прекрасными проектами, чтобы увидеть различные подходы и примеры того, как CSP реализуется в JS.

## asynquence's runner(...): проектирование CSP

Поскольку я интенсивно пытался исследовать применение параллелизма CSP в моём собственном JS-коде, для меня было естественно расширить мою библиотеку для управления асинхронным потоком [asyncquence](http://github.com/getify/asynquence) возможностями CSP.

У меня уже был плагин `runner(...)`, который обрабатывал асинхронные запуски генераторов (см. [«Часть 3: Асинхронность с генераторами ES6»](#async_generators)), поэтому мне пришло в голову, что его можно было бы довольно легко расширить, чтобы он мог обрабатывать несколько генераторов одновременно [в стиле CSP](https://github.com/getify/asynquence/tree/master/contrib#csp-style-concurrency).

Первый вопрос проектирования, который я рассматривал: как узнать, какой генератор получит управление *следующим*?

Можно было бы добавить каждому генератору свой идентификатор, о котором знали бы другие генераторы. Тогда генераторы могли бы адресовывать свои сообщения или передавать управление другому конкретному процессу. Но это решение казалось чрезмерно громоздким и неуклюжим. После различных экспериментов я остановился на простом круговом планировании. Поэтому, если вы соедините три генератора A, B и C, сначала A получит управление, затем, когда A отдаст управление, B начнёт работать, а потом C, когда B отдаст управление, затем снова A и т. д.

Но как мы должны передавать управление? Должен ли быть явный API для этого? Опять же, после многих экспериментов я остановился на более неявном подходе, который кажется (совершенно случайно) похожим на то, как [это делает Коа](http://koajs.com/#cascading): каждый генератор получает ссылку на общий «токен». Когда генератор отдаёт его с помощью yield — это сигнализирует о передаче управления.

Другой вопрос заключается в том, как должен выглядеть канал сообщений. С одной стороны у нас есть довольно формализованный API коммуникации, как в core.async и js-csp (`put(...)` и `take(...)`). После моих собственных экспериментов я склонился к другому, гораздо менее формальному подходу: даже не API, а просто общая структура данных, вроде массива, казалась подходящей и достаточной.

Я решил завести массив `messages`. Вы можете произвольно решить, как вы хотите заполнять/очищать его по мере необходимости. Вы можете добавлять сообщения в массив с помощью `push()`, получать сообщения из массива с помощью `pop()`, назначать разные сообщения по определенным конкретным слотам в массиве, создавать более сложные структуры данных в этих слотах и т. д.

Моё подозрение состоит в том, что для некоторых задач потребуется очень простая передача сообщений, а некоторые будут намного сложнее. Поэтому вместо того, чтобы увеличивать сложность в простых случаях, я решил не накладывать никаких формальных требований на канал сообщений, кроме того, что он должен быть массивом (и, следовательно, нет никакого API, кроме самого массива). Легко наложить дополнительный формализм на механизм передачи сообщений в тех случаях, когда это будет необходимо (смотрите пример *конечного автомата* ниже).

Наконец, я заметил, что эти «процессы» по-прежнему выигрывают по сравнению с [асинхронными возможностями, которые предоставляют автономные генераторы](#async_generators). Другими словами, если вместо того, чтобы отдать токен управления, вы отдаёте Promise (или последовательность *asyncquence*), механизм `runner(...)` действительно остановится, чтобы дождаться этого будущего значения, но **не передаст управление** — вместо этого, он вернёт значение результата обратно в текущий процесс (генератор), чтобы он сохранял контроль.

Этот последний момент может быть (если я правильно интерпретирую вещи) наиболее противоречивым и отличным от других библиотек в этой области. Кажется, что истинный CSP не признаёт такие подходы. Тем не менее, я считаю, что этот вариант очень и очень полезен.

## Простой пример FooBar

Хватит теории. Давайте погрузимся в код:

```js
// Примечание: асинхронные математические функции `multBy20(..)` и
// `addTo2(..)` опущены для краткости

function *foo(token) {
    // берём верхнее сообщение из канала
    var value = token.messages.pop(); // 2

    // кладём другое сообщение в канал
    // `multBy20(..)` - функция на основе промиса,
    // которая умножает значение на `20` после некоторой задержки
    token.messages.push( yield multBy20( value ) );

    // передаём управление
    yield token;

    // последнее сообщение от CSP
    yield "смысл жизни: " + token.messages[0];
}

function *bar(token) {
    // берём верхнее сообщение из канала
    var value = token.messages.pop(); // 40

    // кладём другое сообщение в канал
    // `addTo2(..)` - функция на основе промиса,
    // которая прибавляет к значению `2` после некоторой задержки
    token.messages.push( yield addTo2( value ) );

    // передаём управление
    yield token;
}
```

Хорошо, здесь у нас есть два «процесса»: `*foo()` и `*bar()`. Вы заметите, что оба они передают объект `token` (вы можете назвать его, как хотите, конечно). Свойство `messages` в объекте `token` — это общий канал сообщений. В начале он заполнен сообщением(-ями), переданным ему при запуске CSP (см. ниже).

Выражение `yield token` явно передаёт управление «следующему» генератору (по кругу). Однако функции `yield multBy20(value)` и `yield addTo2(value)` обе отдают промисы (фиктивные отложенные математические функции), а это значит, что генератор в этот момент останавливается и ждёт завершения промиса. После завершения промиса, генератор, у которого в текущий момент находится управление, продолжает выполнение.

Каким бы ни было значение финального выражения `yield`, в нашем случае выражения `yield «смысл жизни...` — это сообщение о завершении выполнения CSP (см. ниже).

Итак, у нас есть два CSP генератора, как запустить их? Будем использовать *asyncquence*:

```js
// инициализируем последовательность с начальным значением `2`
ASQ( 2 )

// запускаем два CSP процесса вместе
.runner(
    foo,
    bar
)

// какое бы сообщение мы не получили, передаём его
// на следующий шаг последовательности
.val( function(msg){
    console.log( msg ); // "смысл жизни: 42"
} );
```

Конечно, это тривиальный пример. Но я думаю, что он прекрасно иллюстрирует концепцию.

Теперь самое время, чтобы [поэкспериментировать с этим примером](http://jsbin.com/tunec/2/edit?js,console) самостоятельно (попробуйте поменять значения!), чтобы убедиться, что эти понятия имеют смысл и что вы можете сами с ними работать!

## Другой демонстрационный пример

Давайте рассмотрим один из классических примеров CSP, но подойдём к нему из моих простых наблюдений, а не с академической точки зрения.

**Пинг-понг**. Весёлая игра, правда? Мой любимый *спорт*.

Представим, что вы реализовали код, который играет в настольный теннис. У вас есть цикл, который запускает игру, и две части кода (например, ветви в инструкции `if` или `switch`), каждая из которых соответствует определённому игроку.

Ваш код работает отлично, а ваша игра — чемпион по пинг-понг!

Но о чём я говорил выше, чем полезна концепция CSP? **Разделение ответственности.** Каковы отдельные ответственности в игре пинг-понг? *Два игрока!*

Таким образом, мы могли бы на высоком уровне спроектировать нашу игру с двумя «процессами» (генераторами), по одному для каждого *игрока*. Когда мы перейдём к деталям, мы поймем, что «склеивающий код», который передаёт управление между двумя игроками, сам по себе является процессом. *Этот* код может быть реализован как третий генератор — *судья*.

Мы пропустим все специфические вопросы, например, ведение счёта, игровая механика, физика, стратегия, искусственный интеллект, элементы управления и т. д. Единственная деталь, о которой мы здесь позаботимся, — передача мячика туда-сюда (которая на самом деле является метафорой для передачи управления в CSP).

**Хотите посмотреть демо?** [Запустите его прямо сейчас](http://jsbin.com/qutabu/1/edit?js,output).

Теперь давайте резберём код строка за строкой.

Во-первых, как выглядит последовательность *asyncquence*?

```js
ASQ(
    ["ping","pong"], // имена игроков
    { hits: 0 } // мяч
)
.runner(
    referee,
    player,
    player
)
.val( function(msg){
    message( "судья", msg );
} );
```

Мы создали последовательность с двумя начальными сообщениями: `['ping', 'pong']` и `{ hits: 0 }`. Мы скоро до них доберемся.

Затем мы запустили CSP из трех процессов (сопрограмм): один экземпляр `*referee()` и два экземпляра `*player()`.

Окончательное сообщение в конце игры передаётся на следующий шаг в нашей последовательности, а затем выводится как *сообщение от судьи*.

Реализация судьи:

```js
function *referee(table){
    var alarm = false;

    // судья устанавливает таймер для игры
    // на своем секундомере (10 секунд)
    setTimeout( function(){ alarm = true; }, 10000 );

    // продолжайте игру
    // пока не зазвучит таймер
    while (!alarm) {
        // позволяет игрокам играть
        yield table;
    }

    // сигнал игрокам о том, что игра окончена
    table.messages[2] = "CLOSED";

    // что говорит судья?
    yield "Время вышло!";
}
```

Я назвал токен управления `table` в соответствии с проблемной областью (игра в настольный теннис). Это хорошая аналогия — игрок «отдает стол» другому, когда он отбивает мяч назад, не так ли?

Цикл `while` в `*referee()` просто продолжает отдавать стол игрокам, пока не вышло время на секундомере. Когда это происходит, он берёт управление и объявляет `"Время вышло!"`.

Теперь взглянем на генератор `*player()` (мы используем два экземпляра этого генератора):

```js
function *player(table) {
    var name = table.messages[0].shift();
    var ball = table.messages[1];

    while (table.messages[2] !== "CLOSED") {
        // ударяет по мячу
        ball.hits++;
        message( name, ball.hits );

        // искусственная задержка, когда мяч возвращается к другому игроку
        yield ASQ.after( 500 );

        // игра всё ещё продолжается?
        if (table.messages[2] !== "CLOSED") {
            // мяч снова вернулся на сторону другого игрока
            yield table;
        }
    }

    message( name, "Игра окончена!" );
}
```

Первый игрок берёт себе в качестве имени первый элемент из массива сообщений (`"ping"`), затем второй игрок берёт второй элемент. Таким образом, они оба корректно себя идентифицируют. Оба игрока также хранят ссылку на общий объект `ball` (со счётчиком `hits`).

Пока игроки не услышат финальное сообщение от судьи, они «ударяют» по мячу, увеличивая счетчик `hits` (и выдают сообщение, чтобы объявить об этом). Затем они ждут 500 мс (просто чтобы имитировать полёт мяча, который *не* может путешествовать со скоростью света!).

Если игра всё ещё продолжается, они «отдают стол» другому игроку.

If the game is still going, they then "yield the table" back to the other player.

Это всё!

[Взгляните на код демо](http://jsbin.com/qutabu/1/edit?js,output), чтобы понять весь код в контексте и увидеть, как все части работают вместе.

## Конечный автомат: генераторы-сопрограммы

Последний пример: создание [конечного автомата](http://en.wikipedia.org/wiki/Finite-state_machine) как набора генераторов-сопрограмм, которые управляются простым помощником.

[Демо](http://jsbin.com/luron/1/edit?js,console).

Сначала давайте определим помощника для управления обработчиками конечного состояния:

```js
function state(val,handler) {
    // обработчик сопрограммы (обертка) для этого состояния
    return function*(token) {
        // обработчик перехода состояния
        function transition(to) {
            token.messages[0] = to;
        }

        // начальное состояние по умолчанию (если ещё не установлено)
        if (token.messages.length < 1) {
            token.messages[0] = val;
        }

        // продолжать, пока не будет достигнуто конечное состояние (false)
        while (token.messages[0] !== false) {
            // этот обработчик соответствует текущему состоянию?
            if (token.messages[0] === val) {
                // делегирует обработчику состояния
                yield *handler( transition );
            }

            // передать управление другому обработчику состояния?
            if (token.messages[0] !== false) {
                yield token;
            }
        }
    };
}
```

Эта вспомогательная функция `state(...)` создаёт [делегирующий генератор](#es6_generators_dive) для определённого значения состояния, который автоматически запускает конечный автомат и передаёт управление при каждом изменении состояния.

Исключительно по соглашению, я решил, что общий слот `token.messages[0]` будет содержать текущее состояние нашего конечного автомата. Это означает, что вы можете установить начальное состояние, передав сообщение с предыдущего шага последовательности. Но если такое начальное сообщение не передаётся, мы просто по умолчанию устанавливаем в качестве начального состояния первое состояние. Кроме того, по соглашению, значение `false` принято за финальное состояние, при котором конечный автомат завершает работу. Это легко изменить, если вы посчитаете нужным.

Значения состояния могут быть любыми, какими хотите: числами, строками и т. д. Если значение может быть строго проверено на равенство с помощью `===`, вы можете использовать его для своих состояний.

В следующем примере я показываю конечный автомат, который переходит между четырьмя числовыми состояниями в определённом порядке: `1 -> 4 -> 3 -> 2`. Для демонстрационных целей здесь также используется счётчик, чтобы конечный автомат мог выполнить цикл перехода не более одного раза. Когда наш конечный автомат достигает состояния прерывания (`false`), последовательность *asyncquence* переходит на следующий шаг, как и ожидается.

```js
// счётчик (исключительно для демонстрации)
var counter = 0;

ASQ( /* необязательно: значение начального состояния */ )

// запуск конечного автомата, переходы: 1 -> 4 -> 3 -> 2
.runner(

    // обработчик состояния `1`
    state( 1, function*(transition){
        console.log( "in state 1" );
        yield ASQ.after( 1000 ); // пауза 1с
        yield transition( 4 ); // переход к состоянию `4`
    } ),

    // обработчик состояния `2`
    state( 2, function*(transition){
        console.log( "in state 2" );
        yield ASQ.after( 1000 ); // пауза 1с

        // только для демонстрационных целей, 
        // продолжайте движение по циклу состояний?
        if (++counter < 2) {
            yield transition( 1 ); // переход к состоянию `1`
        }
        // всё сделано!
        else {
            yield "Это всё, люди!";
            yield transition( false ); // переход к состоянию прерывания
        }
    } ),

    // обработчик состояния `3`
    state( 3, function*(transition){
        console.log( "in state 3" );
        yield ASQ.after( 1000 ); // пауза 1с
        yield transition( 2 ); // переход к состоянию `2`
    } ),

    // обработчик состояния `4`
    state( 4, function*(transition){
        console.log( "in state 4" );
        yield ASQ.after( 1000 ); // пауза 1с
        yield transition( 3 ); // переход к состоянию `3`
    } )

)

// конечный автомат завершён, двигаемся дальше
.val(function(msg){
    console.log( msg );
});
```

Довольно легко проследить, что здесь происходит.

Выражение `yield ASQ.after(1000)` показывает, что эти генераторы могут при необходимости выполнять любые асинхронные операции на основе промисов/последовательностей, как мы видели ранее. Выражение `yield transition(...)` осуществляет переход к новому состоянию.

Наш помощник `state(...)` на самом деле выполняет всю *тяжёлую работу* по обработке [делегирования yield*](#async_generators) и жонглированию состояниями, поэтому обработчики состояния могут быть простыми и естественными.

## Заключение

Ключ к CSP заключается в объединении двух или более «процессов» генераторов вместе, предоставляя им общий канал связи и способ передачи управления между собой.

Существует несколько библиотек, которые используют более или менее формальный подход в JS, который соответствует Go и Clojure/ClojureScript API и/или семантике. За всеми этими библиотеками стоят действительно умные разработчики, и все они представляют собой большие ресурсы для дальнейшего исследования.

Библиотека [asynquence](http://github.com/getify/asynquence) пытается использовать менее формальный подход, надеясь, тем не менее, сохранить основную механику. Плагин `runner(...)` из *asynquence* позволяет довольно легко начать играть с CSP-подобными генераторами, пока вы экспериментируете и учитесь.

Наилучшая часть состоит в том, что CSP в *asynquence* работают [вместе с остальными](https://davidwalsh.name/asynquence-part-1) её [асинхронными возможностями](https://davidwalsh.name/asynquence-part-2) (промисами, генераторами, потоком управления и т. д.). Таким образом, вы получаете лучшее из всех миров и можете использовать любые инструменты, подходящие для задачи, — всё в одной небольшой библиотеке.

Теперь, когда мы довольно подробно изучили генераторы по этим четырём постам, я надеюсь, что вы взволнованы и вдохновлены исследовать, как вы можете преобразовать свой собственный асинхронный JS-код! Что вы будете разрабатывать с помощью генераторов?
