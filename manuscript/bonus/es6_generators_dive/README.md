# Глубокое погружение в генераторы ES6

*Перевод статьи Kyle Simpson: [Diving Deeper With ES6 Generators](https://codeburst.io/generators-in-javascript-1a7f9f884439)*

*Дата публикации: 27.07.2014*

## Генераторы ES6: Полная серия

1. [Основы генераторов ES6](bonus/es6_generators_basic/README.md)
2. [Глубокое погружение в генераторы ES6](bonus/es6_generators_dive/README.md)
3. [Асинхронность с генераторами ES6](bonus/async_generators/README.md)
4. [Параллелизм с генераторами ES6](bonus/concurrent_generators/README.md)

Если вы ещё не знакомы с генераторами ES6, сначала прочитайте и поиграйтесь с кодом в статье «[Часть 1: Основы генераторов ES6](bonus/es6_generators_basic/README.md)». Как только вы решите, что поняли основы, мы погрузимся в некоторые более глубокие детали.

## Обработка ошибок

Одна из наиболее мощных вещей в архитектуре ES6 генераторов заключается в том, что семантика кода внутри генератора является **синхронной**, даже если внешний контроль осуществляется асинхронно.

Это причудливый/сложный способ сказать, что вы можете использовать простые техники обработки ошибок, которые наверняка хорошо знаете — а именно механизм `try...catch`.

Например:

```js
function *foo() {
    try {
        var x = yield 3;
        console.log( "x: " + x ); // может никогда не выполниться!
    }
    catch (err) {
        console.log( "Ошибка: " + err );
    }
}
```

Несмотря на то, что функция будет приостановлена на выражении `yield 3` и может оставаться приостановленной произвольное время, если ошибка будет отправлена обратно генератору, конструкция `try...catch` поймает её! Попробуйте сделать это в асинхронном коде, например в колбэке. :)

Но как именно ошибка будет отправлена в генератор?

```js
var it = foo();

var res = it.next(); // { value:3, done:false }

// вместо обычного возобновления очередным вызовом `next (..)`,
// давайте бросим гаечный ключ (ошибку) в шестерни:
it.throw( "Упс!" ); // Ошибка: Упс!
```

Здесь вы можете видеть, что мы используем другой метод итератора — `throw(...)` — который «бросает» ошибку в генератор, как если бы она произошла в той точке, где генератор в настоящий момент приостановлен. Конструкция     `try...catch` ловит эту ошибку, как и следовало ожидать!

**Примечание:** если `throw(...)` бросает ошибку в генератор, но `try...catch` не ловит её, ошибка (как и в обычной функции) распространится обратно (и если не поймать её, в конечном итоге окажется необработанным исключением). Вот так:

```js
function *foo() { }

var it = foo();
try {
    it.throw( "Упс!" );
}
catch (err) {
    console.log( "Ошибка: " + err ); // Ошибка: Упс!
}
```

Очевидно, что обратное направление обработки ошибок также работает:

```js
function *foo() {
    var x = yield 3;
    var y = x.toUpperCase(); // может быть ошибка приведения типа TypeError!
    yield y;
}

var it = foo();

it.next(); // { value:3, done:false }

try {
    it.next( 42 ); // `42` не имеет метода `toUpperCase()`
}
catch (err) {
    console.log( err ); // TypeError (из вызова `toUpperCase()`)
}
```

## Делегирование генераторов

Другая вещь, которую вам, возможно захочется сделать — вызвать другой генератор внутри функции-генератора. Я имею в виду не инициализацию генератора обычным способом, и именно делегирование управления другому генератору. Чтобы это сделать, используется вариант ключевого слова `yield`: `yield *` («yield звёздочка»).

Пример:

```js
function *foo() {
    yield 3;
    yield 4;
}

function *bar() {
    yield 1;
    yield 2;
    yield *foo(); // `yield *` делегирует управление итерацией `foo()`
    yield 5;
}

for (var v of bar()) {
    console.log( v );
}
// 1 2 3 4 5
```

Как я объяснял в части 1 (где я использовал `function *foo() {}` вместо `function* foo() {}`), я также предпочитаю `yield *foo()` вместо варианта `yield* foo()`, который используется во многих других статьях/документации. Я думаю, что такое написание более точно показывает, что происходит.

Давайте разберёмся, как это работает. Выражения `yield 1` и `yield 2` посылают свои значения напрямую при неявных вызовах `next()` в цикле `for...of`, как мы уже поняли и ожидали.

Но тут встречается `yield*`, и вы заметите, что он отдаёт другой генератор, фактически инстанцируя его (`foo()`). Таким образом, мы уступаем/делегируем управление итератору другого генератора — возможно, это самый точный способ подумать об этом.

После того, как `yield*` делегировал (временно) управление с `*bar()` на `*foo()`, метод `next()` в цикле `for...of` на самом деле вызывается у генератора `foo()`, таким образом, `yield 3` и `yield 4` отправляют свои значения в цикл.

Когда `*foo()` завершается, управление возвращается в исходный генератор и выполняется последнее выражение `yield 5`.

Для простоты, этот пример только отдаёт значения наружу. Но конечно, если вы не используете цикл `for...of`, а вручную вызываете метод итератора `next(...)` и передаёте сообщения, эти сообщения передаются через `yield*` таким же ожидаемым способом:

```js
function *foo() {
    var z = yield 3;
    var w = yield 4;
    console.log( "z: " + z + ", w: " + w );
}

function *bar() {
    var x = yield 1;
    var y = yield 2;
    yield *foo(); // `yield *` делегирует управление итерацией `foo()`
    var v = yield 5;
    console.log( "x: " + x + ", y: " + y + ", v: " + v );
}

var it = bar();

it.next();      // { value:1, done:false }
it.next( "X" ); // { value:2, done:false }
it.next( "Y" ); // { value:3, done:false }
it.next( "Z" ); // { value:4, done:false }
it.next( "W" ); // { value:5, done:false }
// z: Z, w: W

it.next( "V" ); // { value:undefined, done:true }
// x: X, y: Y, v: V
```

Хотя я показал здесь только один уровень делегирования, `*foo()` может с помощью `yield*` делегировать управление другому генератору, затем другому и так далее.

Другой «трюк», который может делать `yield*` — получать значение, переданное с помощью `return` из другого генератора.

```js
function *foo() {
    yield 2;
    yield 3;
    return "foo"; // возвращает значение обратно в выражение `yield*`
}

function *bar() {
    yield 1;
    var v = yield *foo();
    console.log( "v: " + v );
    yield 4;
}

var it = bar();

it.next(); // { value:1, done:false }
it.next(); // { value:2, done:false }
it.next(); // { value:3, done:false }
it.next(); // "v: foo"   { value:4, done:false }
it.next(); // { value:undefined, done:true }
```

Как видите, `yield *foo()` делегирует управление (вызовы `next()`) генератору `foo()`, пока он не завершится. Когда это произойдёт, любое возвращаемое значение (в этом случае, строка `"foo"`) станет результатом выражения `yield*` и будет присвоено локальной переменной `v`.

В этом заключается интересное различие между `yield` и `yield*`: результат выражения `yield` — значение, переданное в последующий метод `next()`, а результат выражения `yield*` — возвращаемое с помощью `return` значение генератора, которому `yield*` делегирует управление (поскольку значения, переданные в метод `next()`, прозрачно проходят сквозь делегирование).

That's an interesting distinction between `yield` and `yield*`: with `yield` expressions, the result is whatever is sent in with the subsequent `next(..)`, but with the `yield*` expression, it receives its result only from the delegated generator's `return` value (since `next(..)` sent values pass through the delegation transparently).

Вы также можете обрабатывать ошибки (смотрите выше) в обоих направлениях через `yield*`:

```js
function *foo() {
    try {
        yield 2;
    }
    catch (err) {
        console.log( "foo поймал: " + err );
    }

    yield; // остановка

    // теперь выбросим другую ошибку
    throw "Упс!";
}

function *bar() {
    yield 1;
    try {
        yield *foo();
    }
    catch (err) {
        console.log( "bar поймал: " + err );
    }
}

var it = bar();

it.next(); // { value:1, done:false }
it.next(); // { value:2, done:false }

it.throw( "Ой ой!" ); // будет поймана внутри `foo()`
// foo поймал: Ой ой!

it.next(); // { value:undefined, done:true }  --> Здесь нет ошибки!
// bar поймал: Упс!
```

Как видите, `throw("Ой ой!")` выбрасывает ошибку через `yield*` и эта ошибка обрабатывается конструкцией `try...catch` внутри `*foo()`. Точно также `throw "Упс!"` внутри `*foo()` выбрасывает ошибку обратно в `*bar()`, который ловит её с помощью другой конструкции `try...catch`. Если бы мы не поймали ни одной из них, ошибки продолжили бы распространяться, как и ожидается обычно.

## Заключение

Генераторы имеют синхронную семантику выполнения, а это означает, что вы можете использовать механизм обработки ошибок `try..catch` сквозь `yield`. Итератор генератора также имеет метод `throw(...)`, чтобы выбросить ошибку в генератор, пока он находится в приостановленном состоянии. Эта ошибка, конечно же, может быть отловлена конструкцией `try..catch` внутри генератора.

Выражение `yield*` позволяет делегировать управление итерацией из текущего генератора другому. В результате и сообщения, и ошибки передаются в обоих направлениях через `yield*`.

Но один фундаментальный вопрос до сих пор остаётся без ответа: как генераторы помогают нам с асинхронным кодом? Всё, что мы видели до сих пор в этих двух статьях, — это синхронная итерация функций-генераторов.

Ключ будет заключаться в создании механизма, в котором генератор останавливается, чтобы запустить асинхронную задачу, а затем возобновляется (с помощью вызова метода `next()` у итератора), когда асинхронная задача завершается. В следующей статье мы рассмотрим различные способы создания такого управления асинхронностью с помощью генераторов. Будьте на связи!