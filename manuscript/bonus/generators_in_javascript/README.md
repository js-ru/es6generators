# Генераторы в JavaScript

## Делаем асинхронный код красивым с ES6

*Перевод статьи Yash Agrawal: [Generators in JavaScript](https://codeburst.io/generators-in-javascript-1a7f9f884439)*

*Дата публикации: 16.08.2017*

Генераторы — это передовая особенность в JavaScript ES6. При однопоточной модели выполнения в JavaScript сложно управлять асинхронным кодом, а генераторы и обещания (промисы) — долгожданные возможности в JS-арсенале. Давайте подробнее рассмотрим генераторы в этой статье.

## Генераторы

Генераторы представляют собой специальный тип функций. В отличие от традиционных функций генераторы производят несколько значений по запросу, приостанавливая своё выполнение между этими запросами. В эпоху до ES6 эту роль играли объекты, написанные как [итераторы](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators). Однако такие объекты сложнее поддерживать в основном из-за необходимости хранить внутреннее состояние.

### Как реализованы генераторы?

Взгляните на фрагмент кода ниже из официальной документации на MDN. Вы увидите, что синтаксис генераторов очень похож на синтаксис обычных функций, но имеет некоторые интересные отличия.

```js
function* idMaker() {
  var index = 0;
  while(true)
    yield index++;
}

var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
// ...
```

Ключевые слова `function*` и `yield` уникальны для генераторов. Генераторы определяются добавлением символа `*` в конце ключевого слова `function`. Это позволяет использовать ключевое слово `yield` в теле генератора для производства значений по запросу. Давайте разберём этот фрагмент строка за строкой.

В **строке 1** мы используем `function*` для создания генератора. В **cтроке 4** используется ключевое слово `yield`, которое производит значение по запросу. В **строке 7** мы вызываем функцию-генератор. Вызов функции-генератора не выполняет её, а создаёт объект-итератор, которые помогает взаимодействовать с генератором. Посмотрите на схему ниже, чтобы понять, как это работает.

![Поток фрагмента кода 1](images/generators_in_javascript-1.png "Поток фрагмента кода 1")

Обратите внимание: в фрагмент кода, который мы рассматривали, никогда не достигнет `gen.done = true`, поскольку имеет внутри бесконечный цикл.

### За сценой — как генераторы работают внутри

В начале статьи упоминалось, что генераторы — это «специальные» функции в том смысле, что они могут останавливать своё выполнение. Генератор имеет следующие состояния:

- Приостановлен в начале (Suspended Start)
- Выполняется (Executing)
- Приостановлен на yield (Suspended Yield)
- Завершён (Completed)

Рассмотрим более простой фрагмент кода, чтобы понять состояния и контекст выполнения функции-генератора.

```js
function* myGenerator() {
  yield '1';
  yield '2';
}

var gen = myGenerator();

const result1 = gen.next();
// result1 = {value = '1'; done = false}
const result2 = gen.next();
// result2 = {value = '2'; done = false}
const result3 = gen.next();
// result3 = {value = undefined; done = true}
```

**Строка 1** определяет генератор, который имеет два выражения `yield`. В **строке 6** создаётся объект-итератор. В **строке 8**, **строке 10** и **строке 12** генератор активируется и запрашивается значение.

![Состояния генератора](images/generators_in_javascript-2.png "Состояния генератора")

Как только создаётся итератор, генератор переходит в состояние «Приостановлен на старте». После первого вызова `gen.next()` генератор переходит в режим выполнения, выполняется до первого выражения `yield`, после чего приостанавливается и переходит в состояние «Приостановлен на yield». Когда генератор получает следующий запрос `gen.next()`, он выполняется до следующего `yield`, и снова переходит в состояние «Приостановлен на yield». Этот процесс продолжается циклически, пока не встретится выражение `return` или пока не выполнится весь код. Тогда генератор переходит в состояние «Завершён».

### Контекст выполнения и генераторы

Чтобы лучше понять внутреннюю работу генераторов, мы должны проанализировать, как они влияют на контекст выполнения. Ещё раз посмотрим на фрагмент кода 2, потому что на его основе ниже будет рассмотрен контекст выполнения.

На рисунке 1 показан снимок того, как выглядит контекст выполнения и лексическое окружение до выполнения **строки 6** сниппета 2. Если вам нужно почитать, как работает контекст выполнения и лексическое окружение, прочитайте мою статью о [подъёме переменных](https://codeburst.io/hoisting-in-javascript-515c987336d3).

На шаге 1 выполняется глобальный контекст, из-за подъема переменных у нас есть переменные «result» и объект `gen`, инициализированный значением `undefined`.

![Рисунок 1](images/generators_in_javascript-3.png "Рисунок 1")

Когда выполняется **строка 6**, создаётся объект-итератор, а генератор переходит в состояние «Приостановлен на старте». Смотрите рисунок 2.

![Рисунок 2](images/generators_in_javascript-4.png "Рисунок 2")

После **строки 6** контекст генератора выгружается из стека выполнения, но не выбрасывается, потому что `gen` сохраняет ссылку на него. Выполнение генератора остаётся в той же точке — до выполнения любых выражений `yield`. Смотрите рисунок 3 и следуйте за пунктирной линией, чтобы увидеть, как `myGeneration` поддерживается активным, несмотря на то, что он выскочил из стека.

![Рисунок 3](images/generators_in_javascript-5.png "Рисунок 3")

Когда в первый раз вызывается `gen.next()` в глобальном контексте выполнения, генераторы, в отличие от обычных функций, повторно активируют соответствующий контекст выполнения. Контекст `myGenerator()` помещается в верхнюю часть стека, чтобы продолжить выполнение с того места, где он остановился.

![Рисунок 4](images/generators_in_javascript-6.png "Рисунок 4")

После того, как контекст `myGenerator()` вернёт объект со свойствами `value` и `done`, он снова выскочет из стека, но не выбросится, поскольку `gen` содержит ссылку на него. В это время генератор переходит в состояние «Приостановлен на yield» и терпеливо ждёт, пока не будет сделан следующий запрос. Рисунок 5 показывает снимок того, как выглядит контекст/окружение на этом этапе.

![Рисунок 5](images/generators_in_javascript-7.png "Рисунок 5")

После следующего вызова `gen.next()`, генератор снова переходит в состояние выполнения и мы видим картину, похожую на рисунок 4. Процесс повторяется до тех пор, пока значение `result.done` не станет равным `true`. Это сигнализирует о том, что генератор завершил своё выполнение.

Надеюсь, это поможет вам понять, что такое генераторы и как они работают в JavaScript.
