# Передача значений в `next()`

Начнем с другой простой функции-генератора `doMath`. Если мы просто посмотрим на код ниже, нам может показаться, что после вызова `next()` на объекте-генераторе, значение `x` должно быть` 1`, значение `y` должно быть` 11`, а значение `z` должно быть` 110`. Ведь это просто обычная математика, верно?

```js
function *doMath() {
  let x = yield 1;
  let y = yield x + 10;
  let z = yield y * 10;
}
```

Но фактический результат не совпадает ожидаемому. Как показано в приведённом ниже коде, будут выведены следующие значения: `1`,` NaN` и `NaN`.

```js
let func = doMath();
func.next();
// -> {value: 1, done: false}
func.next();
// -> {value: NaN, done: false}
func.next();
// -> {value: NaN, done: false}
func.next();
// -> {value: undefined, done: true}
```

Ключом к пониманию реального результата состоит в том, что значение, переданное вызовом `next()`, в действительности является использованное значение последнего выражения `yield`. Но поскольку мы не передавали какой-либо аргумент при вызове `next()`, то значение каждого выражения `yield` на самом деле всегда будет `undefined`.

При первом вызове `next()` ещё нет последнего выражения `yield`, поэтому это значение по сути игнорируется. При втором вызове `next()` значение последнего выражения `yield`, то есть` yield 1`, устанавливается в `undefined`, которое соответсвенно присваивает `x` значение `undefined`, после чего вычисляет результат `yield x + 10` в значение `NaN`. При третьем вызове `next()` значение последнего выражения `yield`, то есть` yield x + 10`, устанавливается в `undefined`, которое присваивает `y` значение `undefined`, а затем вычисляет результат `yield y * 10` в значение `NaN`.

Теперь мы можем попробовать передать значение при вызове метода `next()` на объекте-генератора. В приведённом ниже коде второй вызов `next()` — `func.next(1)` — передает `1` объекту-генератору, поэтому значение `1` устанавливается в качестве значения для выражения `yield 1`, которое теперь присваивает `x ` значение `1`, и поэтому результатом этого вызова `next()` будет `11`. При третьем вызове `next()` — `func.next(2)` — `2` передаётся в качестве значения для выражения `yield x + 10`, которое присваивает `y` значение `2`, и тогда результатом этого вызова `next()` будет `20`.

```js
let func = doMath();
func.next();
// -> {value: 1, done: false}
func.next(1);
// -> {value: 11, done: false}
func.next(2);
// -> {value: 20, done: false}
func.next(3);
// -> {value: undefined, done: true}
```
